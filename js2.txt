这个函数在内部调用它自己，那么这个函数就叫递归函数
函数防抖: 就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
场景:
1.搜索框搜索输入。只需用户最后一次输入完，再发送请求
2.手机号、邮箱验证输入检测
3.窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。
节流: 限制一个函数在一定时间内只能执行一次
1.滚动加载，加载更多或滚到底部监听
2.谷歌搜索框，搜索联想功能
3.高频点击提交，表单重复提交

全局执行上下文: 它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
函数执行上下文: — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。

当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。
引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。函数中调用函数也是一样,交回控制流程给调用它的所在执行上下文


创建执行上下文有两个阶段: 创建阶段和执行阶段
创建阶段:
1this 值的决定，即我们所熟知的 This 绑定。
2.创建词法环境组件。
3.创建变量环境组件。
this指向 ===在全局执行上下文中，this 的值指向全局对象, 函数中 this 的值取决于该函数是如何被调用的。
let bar = foo.baz;   bar()   this指向window

词法环境  == (1) 环境记录器和 (2) 一个外部环境的引用。
全局环境:（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 null。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 this的值指向全局对象。
函数环境: 函数内部用户定义的变量存储在环境记录器中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。

变量环境====var 被赋值undefine  let const 没有


=====闭包
词法作用域: 是指内部函数在定义的时候就决定了其外部作用域。
作用域链: 每一个作用域都有对其父作用域的引用。当我们使用一个变量的时候，Javascript引擎 会通过变量名在当前作用域查找，若没有查找到，会一直沿着作用域链一直向上查找，直到 global 全局作用域。

当外部作用域执行完毕后:  内部函数还存活（仍在其他地方被引用）时，闭包才真正发挥其作用。
timer中直到清除定时器   event直到清除事件  ajax中直到回调函数执行完


闭包和循环: 闭包只存储外部变量的引用，而不会拷贝这些外部变量的值。--  为什么得到的是for中i的最后值
修复这个问题最简单的方法是在 for 语句块中使用 let 变量声明，这将在每次循环中为 for 语句块创建一个新的局部变量。
方法二: 
var output = function (i) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
};
for (var i = 0; i < 5; i++) {
    output(i);  // 这里传过去的 i 值被复制了
}
console.log(new Date, i);




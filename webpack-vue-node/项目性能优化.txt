===================性能优化
====项目结构
api            //api接口
icons         //svg图标
components  //组件
views        //页面组件
assets       //项目运行时使用到的图片和静态资源
styles          //样式
router       //路由
store         //vuex
util            //工具函数(axios cookie封装)

filters            //全局过滤器
directives      //自定义指令
mixin         //mixin局部混入

errorlog     //错误捕获
vendor       //类库文件

1.网络请求
   cdn  内容分发网络通过中心平台的负载均衡、内容分发、调度等功能模块，
           使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率
   合理使用缓存策略  对于一些类库资源使用强缓存
   gzip压缩  响应头中: Content-Encoding: gzip
   preload: 预先请求加载资源
   prefetch: 让浏览器提前加载下个页面可能会需要的资源
   dns-prefetch:  提前对域名进行解析，减少DNS查找的开销

2.构建相关
   路由懒加载
   合理使用第三方库   element-ui   moment改用day
   删除console.log
   预渲染
   常用的路径创建文件别名    config.resolve.alias
   分析打包后的模块体积   webpack-bundle-analyzer

3.静态资源优化
   图片懒加载  (vue-lazyload)
   使用svg图标      svg-sprite-loader
   使用webp图片  webp图片无损比png图片无损的平均体积要小 20%~40%

4.编码相关
======husky  git提交检测代码
======eslint  stylelint

======cdn
1.将第三方的类库放到cdn上，能够大幅度减少生产环境中的项目体积，另外CDN能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上
2.CDN和服务器的域名一般不是同一个，可以缓解同一域名并发http请求的数量限制,有效分流以及减少多余的cookie的发送（CDN上面的静态资源请求时不需要携带任何cookie）
3.通俗的来说就是使用CDN会一定程度上提升项目中的静态文件的传输速度，在vue-cli3中可以通过externals配置项，将第三方的类库的引用地址从本地指向你提供的CDN地址
4.通过环境变量来判断生产环境才启用CDN，除了需要开启CDN外，你还需要在index.html注入CDN的域名，所以我这里通过html-webpack-plugin根据cdn域名动态的注入script标签，同时需要在index.html中通过模版的语法声明循环的数组和注入的元素
============缓存策略
1.强缓存
     将长时间不会改变的第三方类库或者静态资源设置为强缓存, 
     将max-age设置为一个非常长的时间, 再将访问路径加上哈希达到哈希值变了以后保证获取到最新资源(vue-cli3会自动构建,自己搭建的webpack脚手架需要自行配置contentHash,chunkHash)
2.协商缓存
   对于index.html和一些图片等多媒体资源,可以选择协商缓存（max-age<=0, Last-Modified, ETag）,保证返回服务器最新的资源
============gzip压缩
需要服务端配合
============preload
1.对于SPA应用来说,当浏览器解析完script脚本才会生成DOM节点,
   如果你的项目中没有使用服务端渲染的话且需要加载一个比较耗时的首屏图片时,
  可以考虑将这个首屏图片放在preload标签中让浏览器预先请求并加载执行,
  这样当script脚本执行完毕后就会瞬间加载图片(否则需要等脚本执行完毕后再向后台请求图片)

2.另外使用preload预加载首屏需要的css样式也是一个不错的选择, 类似的库有critical

=============prefetch
prefetch可以让浏览器提前加载下个页面可能会需要的资源,
vue-cli3默认会给所有懒加载的路由添加prefetch属性，
这样可以在你访问使用到懒加载的路由页面时能够获得更快的加载速度
preload和prefetch的区别在于，preload的资源会和页面需要的静态资源并行加载，
而prefetch则会等到浏览器加载完必要的资源后，在空闲时间加载被标记为prefetch的资源

=============dns-prefetch
dns-prefetch可以让浏览器提前对域名进行解析，减少DNS查找的开销,
如果你的静态资源和后端接口不是同一个服务器的话，
可以将考虑你后端的域名放入link标签加入dns-prefetch属性, 京东首页也使用到了dns-prefetch技术

================路由懒加载
1.传统的路由组件是通过import静态的打包到项目中，这样做的缺点是因为所有的页面组件都打包在同一个脚本文件中，导致生产环境下首屏因为加载的代码量太多会有明显的卡顿（白屏）
2.通过import()使得ES6的模块有了动态加载的能力，让url匹配到相应的路径时，会动态加载页面组件，这样首屏的代码量会大幅减少，webpack会把动态加载的页面组件分离成单独的一个chunk.js文件
3.当然懒加载也有缺点，就是会额外的增加一个http请求，如果项目非常小的话可以考虑不使用路由懒加载
=================预渲染
1.在打包完成后，在这个index.html下方还会注入页面的脚本，当用户访问你的项目时，脚本还没有执行，但是可以显示loading动画，因为它是直接注入在html中的，等到脚本执行完毕后，Vue会新生成一个app的节点然后将旧的同名节点删除，这样可以有效的过渡白屏的时间
2.loading动画只是一个让用户感知到你程序正在启动的效果，只是一个静态页面没有任何的功能

================合理使用第三方库
使用day替代moment,  或者moment   优化moment 去掉国际化内容
elment-ui   按需加载
================常用的路径创建文件别名
config.resolve.alias
     .set('@', resolve('src')).set  可以链式调用

================使用可视化工具分析打包后的模块体积
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer')
config
          .plugin('analyzer'),
          use(BundleAnalyzerPlugin)
=================
图片懒加载  (vue-lazyload)
   使用svg图标  svg-sprit-loader
   使用webp图片  webp图片无损比png图片无损的平均体积要小 20%~40%

配合使用picture标签包裹2个source标签,一个提供webp图片,通过srcset属性让浏览器从上到下选择可以支持的图片格式,如果浏览器不支持webp图片会只使用第二个source,会回退到png图片,如果浏览器不支持picture标签,会使用底部的img标签,同样也会生成一个png图片
picture标签的浏览器支持率,相对于webp要好很多（注意底部的img标签无论如何都要有，否则就算支持webp图片也无法渲染出图片）

================压缩图片
1.一些png图片可能质量会非常的高，但是对于Web平台来说，用户可能并不care图片的画质问题，但是如果加载图片导致页面出现卡顿那就显得得不偿失了，我们可以考虑将一些画质较高的图片做压缩处理，我这里使用tinypng帮我压缩图片
2. loader  image-webpack-loader，在用户肉眼分辨不清的情况下一定程度上压缩图片

=================开发过程中技巧
使用require.context这个webpack的api可以避免每次引入一个文件都需要显式的用import导入，
它可以扫描你指定的文件，然后全部导入到指定文件，可以用在
vue-router的路由自动导入
vuex的模块自动导入
svg图标的自动导入
全局组件的自动导入
import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
const  files = require.context('./modules', false, /\.js$/)
const mudules = {}
files.keys().forEach(key => {
	modules[key.replace((\.\.|\.js)/g, '')] = files(key).default
})
export default new Vue.Store({
	modules
})

=====================编码
1.编码这方面主要是减少对DOM的访问，减少浏览器的重排/重绘，访问DOM是非常昂贵的操作，
   因为会涉及到2个不同的线程交互（JS线程和UI渲染线程）
   并且DOM本身又是一个非常笨重的对象，这里给出几个建议
   如果有需要动态创建DOM的需求，可以创建一个文档碎片(DocumentFragment)，
   在文档碎片中操作因为不是在当前文档流不会引起重排/重绘，最后再一次性插入DOM节点

2.避免频繁获取视图信息(getBoundingClientRect,clientWidth,offsetWidth),
   当发生重排/重绘操作时浏览器会维护一个队列，等到超过了最大值或过了指定时间（1000ms/60 = 16.6ms）
   才会去清空队列一次性执行操作，这样可以节省性能，而获取视图信息会立刻清空队列执行重排/重绘

3.高频的监听事件使用函数防抖/节流（可以使用lodash库的throttle函数，但是推荐先搞懂原理）
4.特效可以考虑单独触发渲染层（CSS3的transform会触发渲染层, 动画可以使用绝对定位脱离文档流

=====================封装组件
1.其实我认为自己动手封装一个组件还是很有意义的，因为如果是从零开始编写的组件，
你能够更好的掌握自己组件的所有功能，并且还能根据公司的业务需求定制一些特殊的功能，
除此之外，理解一个组件内部的实现机制也有助于提升个人的编码能力，
而不是别人问起来你只知道我用过某个组件，很好用，但是不知道是怎么做到的。
所以我还是比较推荐去尝试编写几个常用的组件

2.因为是后台管理系统, 核心的组件肯定是表单组件和表格组件,
公共组件是基于element组件的二次封装, 组件的设计遵循以下的思路
 ~高内聚低耦合, 尽可能少的暴露组件的api, 将功能尽量封装在组件内部
 ~组件内部根据业务需求设置了一些组件默认的配置项, 另外再通过不同页面传入不同配置项提高组件的通用性

3.设计组件的目的就是让组件进一步解耦, 将配置项和模板标签分离, 
     一方面是减少在业务逻辑组件中的代码量, 另一方面就是单独抽离的配置项使得能够通过后台动态传递给前端,
     或者自己建一个配置项的js/ts文件
(如果有规范的开发者文档还可以使用nodejs编写一个读取开发者文档一键写入配置项的脚本,
进一步提升开发效率)

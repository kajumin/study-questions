============浏览器缓存机制
(1*)http缓存机制, 其机制是根据http报文的缓存标识进行的
http报文分为: 请求报文和响应报文
请求报文(请求行, http头(通用信息头, 请求头, 实体头), 请求报文主体)
响应报文(状态行, http头(通用信息头, 响应头, 实体头), 响应报文主体)

通用信息头指的是请求报文和响应报文都支持的头域: 
Cache-control, connection, Date, Pragma, Transfer-Encoding,Upgrade, Via

实体头: 实体信息的实体头域, Allow-Content-Base,
Content-Encoding,Content-language, Content-length, content-MD5, content-range, Content-Type
Etag, Expires, Last-Modified, extension-header

缓存分析:
(2*)浏览器和服务器通信的方式为应答模式, 即是: 浏览器发起http请求, 服务端响应请求. 浏览器第一次向服务端发起请求并拿到请求结果, 会根据响应报文中http头中的缓存标识, 决定是否缓存结果, 是则将请求结果和缓存标识存入浏览器缓存中

(3*)
从图中可知: 结论 
1. 浏览器每次请求都会在浏览器缓存中查找该请求的结果和缓存标识
2. 浏览器每次拿到请求结果都会将请求结果和缓存标识存入浏览器缓存中

(4*)根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分, 分别是强缓存和协商缓存

强缓存就是向浏览器缓存查找该请求结果, 并根据该结果的缓存规则来决定是否使用该缓存结果的过程, 强缓存的情况主要有三种: 
(1)不存在该缓存和缓存标识, 强制缓存失败, 直接重新向服务器发起请求(跟第一次请求一致)
(2)存在缓存结果和缓存标识, 但该结果已经失效, 强制缓存失败, 则使用协商缓存(暂不分析)
(3)存在缓存结果和缓存标识, 直接返回结果

(5*)
1.强缓存的缓存规则是什么? 
当浏览器向服务器发起请求时, 服务器会将缓存规则放入http响应报文的http头中和请求结果一起返回给浏览器,
控制强缓存的字段分别是expires和cache-control, 其中cache-control优先级高于expires

expires是http/1.0控制网页缓存的字段, 其值为服务器返回该请求结果缓存的到期时间(绝对值), 即再次发起该请求时,如果客户端的时间小于expires的值时, 直接使用缓存结果.

expires是http/1.0的字段,但是现在浏览器默认使用的是http/1.1, 在http/1.0中expires被cache-control替代了, 原因在于expires控制缓存的原理是使用客户端的时间和服务端的返回时间做对比, 那么如果客户端与服务端的时间因为某些原因(例如时区不同, 客户端和服务端有一方时间不准确)发生误差,那么强制缓存则会直接失效, 这样的话强缓存的存在则毫无意义.

cache-control是如何控制的呢?
在http/1.1中, cache-control是最重要的规则, 主要用于控制网页的缓存,主要取值为:
public:    所有内容都被缓存(客户端和代理服务端都可缓存) private
private:    所有内容只有客户端可以缓存 (默认取值)   [ˈpraɪvət] 
no-cache: 客户端缓存内容, 但是是否使用缓存则需要协商缓存来验证决定
no-store:   所有内容都不会被缓存, 则不使用强缓存和协商缓存
max-age = xxx:  缓存内容将xxx秒后失效

(6*) 
2.浏览器缓存存放在哪里? 如何在浏览器中判断强缓存是否生效? 状态码为灰色
状态码为灰色的请求则代表使用了强制缓存, 请求对应的size值代表了该缓存的位置, 分别为from memory cache和from disk cache

Status  Size
200       memory cache
304       文件大小
 
from memory cache使用内存中的缓存
from disk cache使用硬盘中的缓存
memory => disk   顺序

打开网页 => 关闭网页 => 重新打开(from disk cache) =>刷新(from memory cache) 
内存缓存: 具有快速读取和实效性
      快速读取: 内存缓存会将编译解析后的文件, 直接存入该进程的内存中, 占据该进程一定的内存资源, 以方便下次运行使用时快速读取
      实效性: 一旦该进程关闭, 则该进程的内存则会清空

硬盘缓存: 
       硬盘缓存直接将缓存写入硬盘文件中, 读取缓存需要对该缓存存放的硬盘内容进行i/o操作,然后重新解析该缓存内容, 读取复杂, 速度比内存缓存慢

在浏览器中会将js和图片等文件解析执行后存入缓存中, 那么当页面刷新时直接从内容中读取, 而css文件会存入硬盘文件中, 每次渲染页面都会需要从硬盘中读取缓存

(7*)
协商缓存: 协商缓存就是强制缓存失败后, 浏览器携带缓存标识向服务器发起请求, 由服务器判断缓存标识决定是否使用缓存的过程, 有两种请求:
协商缓存生效: 返回304状态码  使用缓存
协商缓存失败: 返回200状态码  和 请求结果
协商缓存的标识也是在响应报文的http头中和请求结果一起返回给浏览器的, 控制协商缓存的字段分别有:
Last-Modified  If-Modifined-Since  和 Etag / IF-None-Match
Etag / IF-None-Match 优先级高于 last-Modified/ if-modifined-since, 同时存在则etag和if-none-match生效

Last-Modified 是服务器响应请求时, 返回该资源文件在服务器最后被修改的时间
if-Modified-since 客户端再次发起请求时, 携带上次请求返回的last-Modified值, 通过此字段告诉服务器该资源上次请求返回的最后修改时间, 服务器收到请求后, 发现请求头含有if-modified-since, 则会根据字段值与该资源在服务器上最后修改的时间做对比, 若服务器最后修改时间大于if-modifined-since的字段值, 则重新返回资源, 状态码为200, 否则为304,代表无更新, 使用缓存文件.

Etag服务器响应请求时, 返回当前资源文件的一个唯一标识(服务端生成)
If-None-Match是客户端再次发起该请求时, 携带上一次请求返回的唯一标识Etag值, 通过此字段值告诉服务器上次请求返回的唯一标识值, 服务器收到请求后,发现请求头中含有if-none-match 则会根据if-none-match的字段值与该资源在服务器上的etag值做对比, 一致则返回304, 代表资源无更新,  继续使用缓存, 不一致则重新返回资源,状态码为200.

=======跨域
所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。
它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。
(1) jsonp (2) cors跨域资源共享 (3) node.js中间件代理  (4) nginx反向代理
===加密
前端一般使用md5、base64加密、sha1加密



================cookie和session区别
cookie机制采用的是在客户端保持状态的方案, 而session机制采用的是在服务器端保持状态的方案

cookie: 发送一个请求给服务器，服务器给客户端发送cookie，这个cookie的值
是通过响应头名称Set_Cookie的响应头的值，是设置这个值，客户端拿到这个set-cookie之后，
会按照http协议的方式进行解析，把cookie进行保存，接下来当我再次去请求服务器，
客户端会把cookie里面的数据以Cookie: username-jocyce
请求的方式发送到服务器

===http和https
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4、http的连接很简单，是无状态的；
      HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

websocket   性能高   双向通信(双工)
   兼容性强
跨域
jsonp    不安全
ajax       安全

xxs    跨站脚本攻击
csrf   跨站请求伪造

转发  在服务器内部,把请求转交给另一个模块处理,对客户端是不可见的--地址不变
node打印两次是因为高级浏览器会自动去加载  favicon.ico

=================http协议  超文本传输协议  
http 0.9
http 1.0 
http 1.1  20年
http  2    
http  3实验版本
http请求模型:   客户端client  => 请求request  => 服务器server => 响应response => 客户端
客户端请求  接收数据   服务器接收请求 响应数据
输入网址并回车   解析域名(hosts)  浏览器发送请求  服务器处理请求  服务器返回HTML响应  浏览器解析处理HTML  继续处理其他请求

http  基于 tcp  
http3 基于 udp

============OSI七层交换参考模型
1.物理层         通信材料 电压
2.数据链路层   内容寻址    arp  icmp     网卡功能
3.网络层         外网寻址   ip  解决主机到主机的通信问题    ppp(点对点协议)
4.传输层         通信稳定性   tcp(传输控制协议)  udp(用户数据报协议)
5.表现层         统一各种网络结构  
6.会话层         无状态通信
7.应用层         http(超文本传输协议)   ftp(文件传输一些)  smtp(电子邮件传输)  DNS  pop3(邮件) 

无状态通信: 
1.物理层
2.数据链路层     网络接口层(变成四层)     以上硬件要做的事情
3.网络层
4.传输层
5.应用层

一次http操作称为一个事务,  其工作流程分为4步: 
1.首先客户端和服务端需要创建连接  
2.客户端发送请求
   http请求组成: 请求首行  请求头  请求空行 请求体
   请求行  url    请求方式   http协议版本
   请求行( accept accept-language Accept-Encoding(压缩) Cache-Control connection cookie host user-agent)       referer(检查是否同源)
3.服务器响应数据
   http响应组成: 状态行(响应首行)  响应头  请求空行 响应体
   状态行  状态码  报文协议及版本   http/1.1 200 
   响应头 (server  Date  set-cookie content-type expires)
   X-UA-Compatible   网页的兼容性模式设置。
4.客户端收到并显示到浏览器中  然后断开连接
==========
http协议是一个应用层协议，基于TCP协议(传输层)之上，
规定服务器与浏览器之间信息传递规范。使用的默认端口号为80端口

   http    容易被攻击     默认端口号: 80
   https   安全(TLS  SSL) 嵌入到http  加密的通信线路   默认端口号: 443

http1.0   一次性连接
http1.1  保持连接  性能提升
http2.0  
  1.强制https
  2.自带双向通信
  3.多路复用
三次握手  四次挥手

=====tcp  传输控制协议
是一个面向连接的, 可靠的, 基于字节流的传输层通信协议
(1)基于流的方式
(2)面向连接
(3)丢包重传  
(4)保证顺序
=====udp 用户数据报协议
一个无连接的传输协议, udp为应用程序提供了一种无须建立连接就可以发送封装的IP数据包的方法, 
RFC768描述了udp
(1)udp是一个非连接的协议, 不会跟终端建立连接
(2)udp包信息只有8个字节
(3)udp是面向报文的, 既不拆分, 也不合并, 而是保留这些报文的边界
(4)udp可能丢包    只负责发  不会重传   不可靠
(5)不能保证数据顺序

=========http  超文本传输协议  
http协议是一个应用层协议，基于TCP协议（传输层）之上，规定服务器与浏览器之间信息传递规范。使用的默认端口号为80端口

http/0.9: GET , 无状态的特点形成
http/1.0 支持post,head, 添加了请求头和响应头, 支持任何格式的文件发送, 添加了状态码, 多字符集支持, 多部分发送,
权限, 缓存, 内容编码等
http/1.1  默认长连接, 同时6个tcp连接, cdn域名分片
http/2.0  多路复用(一次tcp连接可以处理多个请求), 服务端主动推送, stream传输
http/3     基于UDP实现了QUIC协议
     建立好http2连接
     发送http2扩展帧
     使用QUIC建立连接
     如果成功就断开http2连接
     升级为http3连接

http响应状态码
1XX     告知请求的处理进度和情况
2XX     成功
   200   成功
   204 No content，表示请求成功，但响应报文不含实体的主体部分
3XX     需要进一步处理
   301  moved permanently 永久重定向  --  浏览器不会再请求老的地址
   302  found 临时重定向--浏览器下次还会请求老地址
   // 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
   304  缓存
4XX    客户端错误
   400 bad request     请求报文存在语法错误
   401 unauthorized   表示发送的请求需要有通过http的认证的认证信息
   403 fobidden          表示请求资源被拒绝
   404 not found        表示在服务器上没有找到该资源
5XX    服务端错误
    500    表示服务器端在执行请求时发生了错误
    501    表示服务器不支持当前请求所需要的某个功能
    503    服务暂时处于负载 或 正在停机维护
6XX 自定义

表单: 
get   post    put     delete  
head(响应消息头)   trace (用于检测和诊断)  connect(管道方式)  options(查询服务器性能)

enctype="multipart/form-data"(文件编码格式)   application/x-www-form-urlencoded(浏览器默认的编码格式)
get  与  post 
get    缓存   看的见  容量小  利于分享和收藏
post  容量大  看不见  无法分享和收藏

document.querySelectorAll(..arg);
var $ = document.querySelectorAll.bind(document)

原生js
0.初始化--刚刚创建
1.已连接
2.已发送
3.已接收头
4.已接收body


UDP  用户数据报协议
1.面向报文
是一个面向报文(可以理解为一段一段数据)的协议, 只是报文的搬运工, 不会对报文进行任何的拆分和拼接操作
具体上说: 
    在发送端，应用层将数据传递给传输层的 UDP 协议，UDP只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
    在接收端,   网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接

2.不可靠
(1)UDP是无连接的, 也就是通信不需要建立和断开连接
(2)不可靠的, 协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的
(3)UDP 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP

3.高效
高效的   头部特别小(8个字节)
包含   两个十六位的端口号  源端号和目标端口号
         整个数据报文的长度
         整个数据报文的检验和  用于发现头部和数据中的错误

4. 传输方式: 
 支持一对一  一对多  多对一  单播 多播  广播

1.不保证到达
2.不保证质量
3.不保证顺序

=============TCP   传输控制协议
(1)头部: 
    Sequence number   保证报文都是有序的
    Acknowledgement Number这个序号表示数据接收端期望接收的下一个字节的编号是多少，也表示上一个序号的数据已经收到
    Window Size           窗口大小，表示还能接收多少字节的数据，用于流量控制
    标识符

(2)状态机
HTTP 是无连接的，所以作为下层的 TCP 协议也是无连接的. 虽然看似 TCP 将两端连接了起来，但是其实只是两端共同维护了一个状态
TCP 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。

在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。

第一次握手
客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。

第二次握手
服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

第三次握手
当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ
#停止等待 ARQ
正常传输过程

只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。
报文丢失或出错
在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。
即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。
对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。
1.保证到达
2.保证质量
3.保证顺序
====================http
(1)Get 请求能缓存，Post 不能
(2)Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
(3)Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术
(4)URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
(5)Post 支持更多的编码类型且不对数据类型限制



http首部
Cache-Control   控制缓存的行为
Connection       浏览器优先使用的连接类型   keep-alive
Date    创建报文时间
Pragma   报文指令
请求字段:
Accept   能正确接收的媒体类型 text/html,application/xhtml+xml,application/xml;
Accept-Charset   能正确接收的字符集
Accept-Encoding   能正确接收的编码格式
Accept-Language   能正确接收的语言列表
Expect                     期待行为
Host      服务器域名
User-Agent   客户端信息
Referer   浏览器访问的前一个网页

响应字段
Accept-Range是否支持某些种类的范围
Age	资源在代理缓存中存在的时间
Server	服务器名字
Location	客户端重定向到某个 URL
WWW-Authenticate	获取资源需要的验证信息
Content-Type           内容的媒体类型
Content-Range	内容的位置范围
Content-Location	返回数据的备用地址
Content-Length	request body 长度
Expires	内容的过期时间

=============https
HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。
TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。
在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。

对称加密:  就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。
非对称加密: 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

客户端发送一个随机值，需要的协议和加密方式
服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

握手时使用非对称加密, 传输数据时使用对称加密
都是TLS 1.2协议


http2.0
(1) 多路复用     当页面中需要请求很多资源的时候，队头阻塞
     帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。
(2) 二进制传输:
HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。
(3) Header 压缩
      在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。
      在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header， 后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

(4)服务端Push:  在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。

=================DNS  迭代查询
(1) 操作系统会首先在本地缓存中查询
(2) 没有的话会去系统配置的 DNS 服务器中查询
(3) 如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器
(4) 然后去该服务器查询 google 这个二级域名的服务器
(5) 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP


(1)首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来
(2)接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协       议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层    面的传输了
(3)TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据
(4)数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服    务端会响应一个 HTML 文件
(5)首先浏览器会判断状态码是什么，如果是200那就继续解析，如果400或500的话就会报错，如果300的话会进行重定向，这里会    有个重定向计数器，避免过多次的重定向，超过次数也会报错
(6)浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
(7)文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。
(8)初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
(9)CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
(10)在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了


数据结构
===========栈
栈是一个线性结构，在计算机中是一个相当常见的数据结构。
栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则

===========队列    单链队列和循环队列
队列一个线性结构，
特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。

因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。
循环队列的出队操作平均是 O(1) 的时间复杂度。
===========链表
链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

===========二叉树
树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。
二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。

===========二分搜索树
二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。
这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。

===========AVL树
二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。
AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。

============trie树(字典树)
============并查集

=============堆
堆通常是一个可以被看做一棵树的数组对象。
堆的实现通过构造二叉堆，实为二叉树的一种
(1) 任意节点小于（或大于）它的所有子节点
(2) 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。

将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。
优先队列也完全可以用堆来实现，操作是一模一样的。

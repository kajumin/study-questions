<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	// // 给prototype赋值对象带来的问题
	// // 1.constructor指向Object  同样的访问也会改变
	// function Person(name) {
	//   this.name = name
	// }
	
	// Person.prototype = {
	//  	getName: function() {
	//    		return this.name
	//  	}
	// }   
	// var p1 = new Person('person1')
	// console.log(p1.__proto__.constructor == Object.protype) //true
	// console.log(p1.__proto__.constructor == Object) //true
	// // 2.如果重写constructo指回Person   又会带来construtor变成可遍历的了
	// Person.prototype.constructor = Person;
	// for(let key in p1) {
	// 	console.log(key) //name getName constructor
	// }
	// // 3.对construtor变成不可以遍历的
	// Object.defineProperty(Person.prototype, "constructor", {
	//   enumerable: false,
	//   value: Person
	// });
	
//*****************************prototype上的公有属性 基本数据类型不会变  引用数据类型会变
	function Person2(name) {
	  this.name = name
	}

	Person2.prototype = {
	  constructor: Person2,
	  getName: function() {
	    return this.name
	  },
	  age: 100,
	  names: ['ziyi', 'ziyi1', 'ziyi2']
	}

	var person2 = new Person2('bang')
	person2.names[0] = 'ziyi_modify'
	person2.age = 10  //直接添加到属性中
	Person2.prototype.age = 20  //添加到原型中
	var person3 = new Person2('joycechu')
	
	console.log(person2.names)// ["ziyi_modify", "ziyi1", "ziyi2"]
	console.log(person3.names)// ["ziyi_modify", "ziyi1", "ziyi2"]
	
	console.log(person2.age)// 10  基本数据类型不会变  引用数据类型会变
	console.log(person3.age)// 20  基本数据类型不会变  引用数据类型会变
	console.log(person2)// 多了age属性 
	console.log(person3)//


//***************************************实例上公有属性不会改变  不会互相影响
	function Person3(name) {
	  this.name = name
	  this.names = ['ziyi', 'ziyi1', 'ziyi2']
	}

	Person3.prototype = {
	  constructor: Person3,
	  getName: function() {
	    return this.name
	  }
	}

	var person4 = new Person3()
	person4.names[0] = 'ziyi_modify'
	var person5 = new Person3()
	
	console.log(person5.names)// ['ziyi', 'ziyi1', 'ziyi2']  不会改变

	//新增的原型属性方法  旧的实例不能访问  新的实例可以访问
</script>
</body>
</html>
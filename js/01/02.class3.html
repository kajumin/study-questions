<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	class Es6Person {
	  constructor(name) {
	    // new.target = class Es6Person {}
	    // console.log(new.target) //super的时候会是子类  new时是父类
	    // if(new.target === Es6Person) {   	
	    //   	this.name = name
	    // } else {
	    //   throw new Error('没有用new命令生成实例对象')
	    // }
	    this.name = name
	    
	  }
	  static getClassName() {
    	return Es6Person.name
  	  }
	}

	class Es6WebDeveloper extends Es6Person {
	  constructor(name, age) {
	    // Uncaught ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor
	    // console.log(this)
	    super(name)
	    // console.log(this)
	  }
	}
	// let person = new Es6Person('ziyi2')
	let developer = new Es6WebDeveloper('ziyi2', 11)
	// console.log(person)
	console.log(developer)
	console.log(Es6WebDeveloper.getClassName())  //Es6Person

	// 以下都是子类和父类间隔两层导致的
	console.log(Es6WebDeveloper.prototype)     //Es6Person {constructor: ƒ}
	console.log(Es6WebDeveloper.prototype.__proto__)     //{constructor: ƒ}
	console.log(Es6WebDeveloper.__proto__ === Es6Person) //true
	
	Es6WebDeveloper.prototype = new Es6Person() //true  因为它基于原型链继承
	console.log(Es6WebDeveloper.prototype.__proto__ === Es6Person.prototype)
	// 类似于ES5的寄生组合式继承 子类的原型对象中没有父类的实例对象和实例方法

	// (1)super当做一个对象使用，在子类普通方法（原型对象）中，指向父类的原型对象，因此可以调用父类的原型方法，需要注意的是执行父类的原型方法时，在方法中执行时this指向的是子类的实例对象而不是父类的实例对象

	// (2)如果super用作对象且不在子类的原型对象中调用，而是在子类的静态方法中调用，那么super指代父类而不是父类的原型对象，同理调用父类静态方法时this指向子类而不是父类
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<title></title>

</head>
<!-- 
构造函数模式
可以创建不同实例属性的副本，包括引用类型的实例属性，
   (1)不能共享方法

原型模式
    引用类型的属性对于实例对象而言共享同一个物理空间，因此可以共享方法  
    (1)原型上的引用类型会被修改, 导致所有实例都被修改, 基本数据类型不会

原型链继承
对父类实现方法和属性继承的过程中，父类实例对象的引用类型属性在子类的实例中共享同一个物理空间，因为父类的实例对象指向了子类的原型对象
(1)

借用构造函数
解决了继承中的引用值类型共享物理空间的问题，
(1)没法实现方法的共享

组合继承
属性的继承使用借用构造函数方法，方法的继承使用原型链技术，即解决了引用值类型共享的问题，又实现了方法的共享，但是子类的原型对象中还存在父类实例对象的实例属性

寄生组合继承
组合继承已经可以解决大部分问题，但是也有缺陷，就是会调用两次父类的构造函数，一次是实现原型时使子类的原型等于父类的实例对象调用了父类构造函数（同时在子类的原型对象中还存在了父类实例对象的实例属性），一次是使用子类构造函数时调用了一次父类构造函数。寄生组合式继承可以解决在继承的过程中子类的原型对象中还存在父类实例对象的实例属性的问题。 -->
<body>
	<!-- 
	1.构造函数模式 可以创建不同实例属性的副本，包括引用类型的实例属性，但是不能共享方法 
	
	2.原型模式 引用类型的属性对于实例对象而言共享同一个物理空间，因此可以共享方法
	
	3.原型链	对父类实现方法和属性继承的过程中，父类实例对象的引用类型属性在子类的实例中共享同一个物理空间，因为父类的实例对象指向了子类的原型对象
	
	4.借用构造函数 解决了继承中的引用值类型共享物理空间的问题，但是没法实现方法的共享
	5.组合继承 属性的继承使用借用构造函数方法，方法的继承使用原型链技术，即解决了引用值类型共享的问题，又实现了方法的共享，但是子类的原型对象中还存在父类实例对象的实例属性
	-->
<script type="text/javascript">
	// 构造函数创建实例对象和工厂模式相似
	// 缺点: 没有公有属性方法
	// function Father(name, age, hobbies) {
	//   this.name = name;
	//   this.age = age;
	//   this.hobbies = hobbies;
	// }

	// let f1 = new Father('bang', 20, ['php','java','javascript']);
	// let f2 = new Father('joycechu', 18, ['php','java','javascript']);
	// console.log(f1) // Father {name: "bang", age: 20, hobbies: Array(3)}
	// console.log(f1 === f2) //false
	// console.log(f1.hobbies == f2.hobbies) //false

	// 原型模式  构造函数定义实例属性，原型对象定义共享的方法和基本数据类型的属性
	// 优点: 有公共属性方法
	// 注意: 修改原型链上属性基础数据类型, 会再实例上创建覆盖
	//       修改原型链上的引用类型可以, 不会在实例上创建
	function Father(names) {
	  this.names = names;
	}
	Father.prototype.sayHello = function(){
		console.log(this.names)
	}
	Father.prototype.myCountry = 'china'; //基本数据不会改变
	Father.prototype.hobby = ['音乐','游泳','跳舞']; //基本数据不会改变

	let f1 = new Father(['bang','joycechu','kajumin']);
	f1.myCountry = 'janpan'; 
	f1.hobby.push('乒乓球')
	let f2 = new Father(['bang2','joycechu2','kajumin2']);
	
	console.log(f1.hobby) //["乒乓球", "游泳", "跳舞"]
	console.log(f1.hobby === f2.hobby) //true
	f1.sayHello()
	f2.sayHello() 
	console.log(f1, f2) //janpan china
	// 修改基本类型会在对象中覆盖
	console.log(f1.myCountry === f2.myCountry) //false 
	console.log(f1.myCountry, f2.myCountry) //janpan china
	
</script>
</body>
</html>
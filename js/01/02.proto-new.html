<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<!-- 
	1.借助call实现继承
	  父类属性可以继承, 但是父类原型对象上属性没有继承
	2.借助原型链实现继承
	  父类原型对象上属性可以继承, 但是父类属性是引用类型一改则都改,
	  因为父类属性在子类的原型对象上
	3.组合继承  结合原型链继承和借助call实现继承
	  父构造函数会执行了两次
	4.组合继承的优化1
	  Child.prototype = Parent.prototype
	  constructor指向Parent
	 -->
<script type="text/javascript">
	// 1.借助call实现继承
  function Parent1(){
    this.name = 'parent1';
  }
  function Child1(){
    Parent1.call(this);
    this.type = 'child1'
  }
  console.log(new Child1);

	//2.借助原型链实现继承
	function Parent2() {
	    this.name = 'parent2';
	    this.play = [1, 2, 3]
	}
	function Child2() {
	   this.type = 'child2';
	}
	Child2.prototype = new Parent2();
	var s2 = new Child2()
	console.log(s2);
	console.log(s2.__proto__.__proto__.__proto__.__proto__);//null

	// 组合继承
	function Parent3 () {
	    this.name = 'parent3';
	    this.play = [1, 2, 3];
  }
  function Child3() {
    Parent3.call(this);
    this.type = 'child3';
  }
  Child3.prototype = new Parent3();
  var s3 = new Child3();
  var s4 = new Child3();
  s3.play.push(4);
  console.log(s3)
  console.log(s3.play, s4.play);

  //4.组合继承的优化1
  function Parent4 () {
    this.name = 'parent4';
    this.play = [1, 2, 3];
  }
  function Child4() {
    Parent4.call(this);
    this.type = 'child4';
  }
  Child4.prototype = Parent4.prototype;
  var s3 = new Child4();
  var s4 = new Child4();
  console.log(s3)

  //5.组合继承的优化2 --寄生组合式继承
   function Parent5 () {
    this.name = 'parent5';
    this.play = [1, 2, 3];
  }
  function Child5() {
    Parent5.call(this);
    this.type = 'child5';
  }
  Child5.prototype = Object.create(Parent5.prototype);
  Child5.prototype.constructor = Child5;
  var c5 = new Child5()
  console.log(c5)
</script>
</body>
</html>
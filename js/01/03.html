<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	// this要执行时才能确定  定义时无法确定
	var  a = {
		name: 'A',
		fn: function() {
			console.log(typeof this.name)  //string
			console.log(this.name)
		}
	}

	a.fn();  //A
	a.fn.call({name:'B'});  //B
	var fn1 = a.fn; 
	fn1();  // ''  空字符
	// call  apply bind
	// bind返回函数

	function  fn(name) {
		console.log(this)  //{age: 20}
		console.log(name)
	}
	fn.call({age: 20},'zhangsan')

	fn.bind({age:20},'lisi')();


	// js没有块级作用域 {}  只有函数作用域和全局作用域
	// 当前作用域没有定义的变量,即自由变量
	
	// 闭包
	function fn2 () {
		var aa = 100;
		return function() {
			console.log(aa)  //自由变量,在父级变量中找
			console.log(bb)  //300 window中找
		}
	}
	var f1 = fn2();
	var aa = 200;
	var bb = 300;  
	f1(); // 100

	// 1.变量提升的理解  变量定义和函数声明
	// 2.创建10个a标签,点击时弹出来对应的序号
	console.log(fn3)  //fn3  函数提升优先于变量 与两者顺序无关   函数提升过就不会有赋值的感觉了
	
	
	
	function fn3() {
		console.log('123')
	}
	var fn3 = 200;
	var fn3 = function() {
		console.log('123')
	}

	console.log(fn3) //200  因为函数提升 而不会赋值的感觉

	var i;
	for(i = 0;i < 10;i ++) {
		a = document.createElement('a');
		a.innerHTML = i + '<br>';
		(function(i){
			a.addEventListener('click',function(e) {
				e.preventDefault();
				alert(i);
			})
		})(i)

		document.body.appendChild(a);
	}


	// 闭包实用
	function  isRepeat() {
		var list = [];
		return function (id) {
			// console.log(list)
			if(list.indexOf(id) >= 0){
				return true;
			}else {
				list.push(id);
				return false;
			}
		}
	}
	var i = isRepeat();
	console.log(i(10)); //true
	console.log(i(10)); //false
</script>
</body>
</html>
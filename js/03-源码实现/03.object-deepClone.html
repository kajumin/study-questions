<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- 
基本类型(值类型, 原始类型): number string boolean undefined null symbol
引用类型(复杂数据类型): object array function Date

1.在内存中的位置不同
基本类型: 占用空间固定, 保存在栈中
引用类型: 占用空间不固定, 保存在堆中

栈: 自动分配内存空间, 它由系统自动释放
堆: 动态分配内存空间, 大小不确定也不会自动释放

2.赋值, 浅拷贝, 深拷贝
基本类型, 赋值是复制基本类型的值给新的变量, 不会互相影响
引用类型, 赋值后二个变量指向同一个地址, 互相影响 
引用类型才有浅拷贝和深拷贝说法
数组: concat  slice Array.from 扩展运算符
对象: Object.assign 展开运算符

深拷贝: 
(1)JSON.parse(JSON.stringify(obj))
   数组: undefind 函数 symbol NaN都转为null
   对象: undefind 函数 symbol都被忽略 NaN转为null
(2)递归拷贝
undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）

3.参数传递
  所有的函数参数都是(按值传递), 跟赋值是一样的
4.数据判断 
  基本类型: typeof  null特殊
  引用类型: instanceof 
  都可以使用: {}.toString.call(obj)

其他: 比较(内存地址) 值的可变性(不可变-基本数据类型)
-->
<script>
	function shadowClone(obj) {
		if(typeof obj != 'object') return 
		
		var newObj = obj instanceof Array ? [] : {};
		for(var key in obj) {
			if(obj.hasOwnProperty(key)) {
				newObj[key] = obj[key]
			}
			
		}
		return newObj
	}

	var obj = { a:1, arr: [2,3] };
	var shadowObj = shadowClone(obj)
	shadowObj.a = 10
	shadowObj.arr[0] = 10
	console.log(obj)
	console.log(shadowObj)

	var arr = [undefined, NaN, Symbol('symbol'), function() {
		console.log(123)
	}]
	var newArr = JSON.parse(JSON.stringify(arr))
	console.log(newArr)
	var obj = {
		un: undefined, 
		nu: Symbol('symbol'), 
		Na: NaN, 
		fun: function() {
			console.log(123)
		}
	}
	var newObj = JSON.parse(JSON.stringify(obj))
	console.log(newObj)


	// 深拷贝
	function deepClone(obj) {
		if(typeof obj != 'object') return
		var newObj = obj instanceof Array ? [] : {}
		for(var key in obj) {
			if(obj.hasOwnProperty(key)) {
				newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]
			}
		}
		return newObj
	}
	var obj = {name: 'bang', list: [1, 2], msg: { age: 20 }}
	var newObj = deepClone(obj)
	newObj.list[0] = 10
	newObj.msg.age = 100
	console.log(obj)
	console.log(newObj)

	var a = null
	console.log(typeof a == 'object' && a == null)
	a = undefined
	console.log(typeof a == 'object' && a == null)
	a = {}
	console.log(typeof a == 'object' && a == null)
	a = arr
	console.log(typeof a == 'object' && a == null)
	console.log(toString.call(arr))
	console.log(toString.call(obj))

	function getType(obj) {
		const str = Object.prototype.toString.call(obj)
		const map = {
			'[object Number]': 'number',
			'[object String]': 'string',
			'[object Boolean]': 'boolean',
			'[object Undefined]': 'undefined',
			'[object Null]': 'null',
			'[object Array]': 'array',
			'[object Object]': 'object',
			'[object Function]': 'function',
			'[object Date]': 'date',
			'[object RegExp]': 'regExp'
		}
		if(obj instanceof Element) {
			return 'element'
		}
		return map[str]
	}

	function deepCopy(obj) {
		const type = getType(obj)
		switch(type) {
			case 'array':
				return copyArray(obj, type)
			case 'object':
				return copyObject(obj, type)
			case 'function':
				return copyFunction(obj, type)
			default: 
				return obj
		}
	}
	function copyArray(obj, type, copy = []) {
		for(const [index, value] of obj.entries()) {
			copy[index] = deepCopy(value)
		}
		return copy
	}
	function copyObject(obj, type, copy = {}) {
		for(const [index, value] of Object.entries(obj)) {
			copy[index] = deepCopy(value)
		}
		return copy
	}
	function copyFunction(obj, type, copy = () => {}) {
		console.log(obj.toString())
		const fun1 = eval(obj.toString())
		fun1.prototype = obj.prototype
		return fun1
	}
	var obj = {list: [1,2,3]}
	var arr = [{ name: 'bang' }]
	function fun() { console.log(1) }
	var newobj = deepCopy(obj)
	var newarr = deepCopy(arr)
	var newfun = deepCopy(fun)
	console.log(newobj == obj)
	console.log(newarr == arr)
	console.log(newfun == fun)

	newobj.list[0] = 10
	newarr[0].name = 'lyt'
	console.log(obj, newobj)
	console.log(arr, newarr)
	console.log(fun, newfun)
	newfun()()
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
  // 对象赋值: 赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间
  var obj1= { name:'bang' }
  var obj4 = obj1;
  obj4.name = 'joycechu'
  console.log(obj1 == obj4)//true
  console.log(obj1)

  // 浅拷贝
  console.log('浅拷贝')
  function shallowClone (source) {
    var objNew = {}
    for(var o in source) {
      if(source.hasOwnProperty(o)) {
        objNew[o] = source[o]
      }
    }
    return objNew
  }
  var shadowObj1 = shallowClone(obj1)
  shadowObj1.name = 'kajumin'
  console.log(shadowObj1 == obj1) 
  console.log(shadowObj1)

  console.log('深拷贝')
  function getType (target) {
    return Object.prototype.toString.call(target).slice(8, -1);
  }
  // function deepClone(target) {

  //   let result, targetType = getType(target)
  //   if (targetType === 'Object') {
  //     result = {}
  //   } else if (targetType === 'Array') {
  //     result = []
  //   } else {
  //     return target
  //   }
  //   for (let i in target) { 
  //     let valueType = getType(target);
  //     let value = target[i]
  //     if (valueType === 'Object' ||
  //      valueType=== 'Array') { 

  //       result[i] = deepClone(value)
  //     } else { 

  //       result[i] = value;
  //     }
  //   }
  function deepClone (target) {
    if(typeof target == 'object') {
      let cloneTarget = Array.isArray(target) ? [] : {};
      // console.log(cloneTarget)
      for(const key in target) {
        if(typeof target == 'object') {
          cloneTarget[key] = deepClone(target[key]);
        }else {
          cloneTarget[key] = target[key];
        } 
      }
      return cloneTarget;
    } else {
      return target;
    }
  } 
  var dobj = deepClone(obj1)
  dobj.name = 'liyitong'
  console.log(obj1)
  console.log(dobj) 
  console.log(obj1 == dobj)
  var arr = [{name:'bang'},2,3];
  var darr = deepClone(arr)
  arr[0].name = 'joycechu'
  console.log(arr) 
  console.log(darr) 
  console.log(arr == darr)

  // //实现深度克隆---对象/数组
  // function clone(target) {
  //   //判断拷贝的数据类型
  //   //初始化变量result 成为最终克隆的数据
  //   let result, targetType = Object.prototype.toString.call(target).slice(8, -1);
  //   if (targetType === 'Object') {
  //     result = {}
  //   } else if (targetType === 'Array') {
  //     result = []
  //   } else {
  //     return target
  //   }
  //   console.log(result)
  //   //遍历目标数据
  //   for (let i in target) {
  //     //获取遍历数据结构的每一项值。
  //     let value = target[i]
  //     //判断目标结构里的每一值是否存在对象/数组
  //     let valueType = Object.prototype.toString.call(target).slice(8, -1);
  //     if (valueType === 'Object' ||
  //      valueType=== 'Array') { 
  //       //对象/数组里嵌套了对象/数组
  //       //继续遍历获取到value值
  //       result[i] = clone(value)
  //     } else { 
  //     //获取到value值是基本的数据类型或者是函数。
  //       result[i] = value;
  //     }
  //   }
  //   return result
  // }

  // console.log(clone({name:'bang',age:20,items: {id: 1}}))

  // var obj1 = {name:"bang",age:20,items:{
  //   id: 1
  // }};
  // var obj2 = {...obj1};
  // obj2.age = 18;
  // obj2.items.id = 1111;
  // console.log(obj1)
  // console.log(obj2)

  // // 内部方法：用户合并一个或多个对象到第一个对象
  // // 参数：
  // // target 目标对象  对象都合并到target里
  // // source 合并对象
  // // deep 是否执行深度合并
  // function extend(target, source, deep) {
  //   // console.log(target,source,deep)
  //     for (key in source)

  //         if (deep && (typeof source[key] === 'object' || Array.isArray(source[key]))) {
  //             // source[key] 是对象，而 target[key] 不是对象， 则 target[key] = {}         
  //     if (typeof source[key] === 'object' && typeof target[key] !== 'object' && !Array.isArray(source[key]))
  //               target[key] = {}       

  //             // source[key] 是数组，而 target[key] 不是数组，则 target[key] = [] 
  //             if (Array.isArray(source[key]) && !Array.isArray(target[key]))
  //                 target[key] = []
  //             // 执行递归
  //             // console.log(target[key], source[key])
  //             extend(target[key], source[key], deep)
              
  //         }
  //         // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了
  //         else if (source[key] !== undefined) target[key] = source[key]
  // }
  // var $ = {};
  // $.extend = function(target){
  //     var deep, args = Array.prototype.slice.call(arguments, 1);

  //     //第一个参数为boolean值时，表示是否深度合并
  //     if (typeof target == 'boolean') {
  //         deep = target;
  //         //target取第二个参数
  //         target = args.shift()
  //     }
  //     // 遍历后面的参数，都合并到target上
  //     args.forEach(function(arg){ extend(target, arg, deep) })
  //     return target
  // }

  // var newObj = $.extend(true,{name:'bang'},{age:20,items: {id: 1}},{sex: '男'})
  // console.log(newObj)
</script>
</body>
</html>
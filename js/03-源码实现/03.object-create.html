<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	/*
	1.create(proto)
	2.myNew(fn, ...args)
	3.instanceof(left, right) 
	4.isprototypeof(left, right)
	5.Object.setPrototypeOf
	5.cache
	6.deepFreeze
	*/
	function create(proto) {
    	function F() {};
    	F.prototype = proto;
    	F.prototype.constructor = F;
    
    	return new F();
	}
	var obj = { name: 'bang' }
	console.log(create(obj))

	// new 
	// 1.创建一个全新的对象，这个对象的__proto__要指向构造函数的原型对象
	// 2.执行构造函数
	// 3.返回值为object类型则作为new方法的返回值返回，否则返回上述全新对象
	function myNew(fn, ...args) {
		// var instance = Object.create(fn.prototype)
		var instance = {}
		instance.__proto__ = fn.prototype
		var res = fn.apply(instance, args)
		return typeof res == 'object' ? res : instance
	}

	var F = function(name, age) {
		this.name = name
		this.age = age
		// return {}
	}
	F.prototype.sayHello = function() {
		console.log('i am ' + this.name)
	}
	var f = myNew(F, 'bang', 'age')
	console.log(f)
	f.sayHello()

	// 一个对象的prototype属性是否在另一个对象的原型上
	function myInstanceof(left, right) {
		var proto = Object.getPrototypeOf(left)
		// console.log(proto)
		while(true) {
			if(proto === null) return false;
			if(proto === right.prototype) return true
			proto = Object.getPrototypeOf(proto)
		}
	}
	console.log(myInstanceof({}, Object))

	function isprototypeof(left, right) {
		// 一个对象是否在另一个对象的原型链上
		var proto = Object.getPrototypeOf(right)
		while (true) {
			if(proto == null) return false
			if(left === proto) return true;
			proto = Object.getPrototypeOf(proto)
		}
		
	}	
	console.log(isprototypeof(Object.prototype, {}))
	console.log(Object.prototype.isPrototypeOf({}))

	// Object.setPrototypeof
	Object.setPrototypeOf = Object.setPrototypeOf || function(obj, proto) {
 	 	obj.__proto__ = proto;
		return	obj; 
	}
</script>
</body>
</html>
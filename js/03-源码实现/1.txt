======1
1.call      利用对象方法指向对象特性
2.apply   与call基本相同   ...args改为  args
3.bind    利用闭包保留原函数和参数, 对于普通函数, 改变this指向, 对于构造函数, 保留原函数原型对象
======2 array数组
1.map      1.统一装入数组中返回
2.filter      1.返回值为真的数组才返回
3.reduce   1.初始值不传怎么处理  2.回调函数的参数有哪些，返回值如何处理
4.flat
    (1)原生  Array.flat(Inifity)
    (2)JSON.stringify(arr)  正则替换[]为''  加上[]  JSON.parse(str)
    (3)递归处理
    (4)reduce  pre.concat(Array.isArray(cur) ? flatten(cur) : cur)

=======3.对象
1.create(proto)  
2.myNew(fn, ...args)   var instance = Object.create(fn.prototype)   var res = fn.apply(instance, args)    
arguments  可用于apply方法
3.instanceof       if(proto == right.prototype) return true;  proto = Object.getPrototypeOf(proto)
4.isprototypeof  if(left == proto) return true; proto = Object.getPrototypeOf(proto)
5.deepFreeze  typeof obj[key] == 'object' ? deepFreeze(obj[key])
6.deepClone  instanceof Array ? [] : {}  obj.hasOwnProperty(key) typeof obj[key] == 'object'
7.cache   var cache  = {}  利用闭包  if(cache[key])
8.原型链 借助call方法 原型链 组合 寄生式  寄生组合式继承

====================函数
1.柯里化curry  将一个参数很多的函数分解成单一参数的多个函数  特点: 延迟计算  返回新的函数
=====================算法
============数组问题  有时会利用对象的特点
1.找出整型数组中乘积最大的三个数
2.寻找连续数组中的缺失数
3.数组去重  [...new Set(arr)]   Array.from(new Set(arr))
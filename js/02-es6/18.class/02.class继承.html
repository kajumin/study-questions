<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>

<!-- 
class的继承: class可以通过extends关键字实现继承
  子类必须在contructor方法调用super方法, 否则新建实例时会报错,
  这是因为子类没有自己的this对象, 而是继承父类的this对象, 然后对其进行加工. 如果不调用super方法, 子类就得不到this对象

  es5的继承实质是先创建子类的实例对象this, 然后再调用父类的方法添加到this上面

  es6的继承机制完全不同, 实质是先创建父类的实例对象this, 然后再在子类的构造函数修改this

  1.Object.getPropertyOf() 用来从子类上获取父类
  Object.getPrototypeOf(ColorPoint) == Point  //true

  2.super关键字: 可以当作函数使用(父类构造函数), 
  也可以当作对象使用(普通方法指向父类的原型对象, 静态方法指向父类)
  无法调用父类的实例属性方法

      (1)new.target指向当前正在执行的函数(子类)

      (2)super调用父类的方法时,super会绑定子类的this

      (3)super对某个属性赋值, 这是super就是this, 赋值的属性会添加到子类实例的属性上, 而读取的时候却是读取父类原型对象上的属性

      (4)super作为对象用在静态方法中, 这时super指向父类, 而不是父类的原型对象

      (5)由于对象总是继承其他对象, 所以可以在任意一个对象中使用super关键字

      (6)无法看出super是作为函数使用还是对象使用时会报错

    3.类的prototype属性和__proto__属性
	B.__proto__ === A
	B.prototypr__proto__ === A.prototype

	4.extends继承的目标: Object 没有任何值 null

	5.子类实例对象的__proto__的__proto__属性指向父类实例的__proto__(父类.prototype)

	6.原生构造函数的继承:
	Boolean
	Number
	String
	Array
	Date
	Function
	RegExp
	Error
	Object

	es6可以做到继承原生构造函数

	7.mixin模式的实现
-->



<script>
	class Point {
		static color = '父类staticColor'
	}
	class ColorPoint extends Point{
		constructor(x) {
			super() //不调用会报错
			this.x = x
			super.superx = 'superx'
		}
		static getStaticColor() {
			return super.color
		}
		getStaticColor() {
			return super.color
		}
		getSuperX() {
			return this.superx
			// return super.superx
		}
	}
	var cp = new ColorPoint(10)
	console.log(cp)
	// console.log(Object.getPrototypeOf(ColorPoint) == Point)
	console.log(cp.getSuperX()) //undefined
	
	// 通过super获取父类静态属性
	console.log(cp.getStaticColor()) // undefined
	console.log(ColorPoint.getStaticColor()) //父类staticColor
	
	const obj = {
		getProp() {
			console.log(super.toString())
		}
	}
	obj.getProp()

	class A {

	}
	class B extends A {
		constructor() {
			super()
		}
	}
	var b = new B()
	console.log(B.__proto__ === A) //true
	console.log(B.prototype.__proto__ === A.prototype)// true

	// extends的继承目标
	// class C extends Object {
	// 	constructor() {
	// 		super()
	// 	}
	// }
	// var c = new C()
	// console.log(C.__proto__ === Object) //true
	// console.log(C.prototype.__proto__ === Object.prototype) //true

	// class C {
	// 	constructor() {
	// 		// super()
	// 	}
	// }
	// var c = new C()
	// console.log(C.__proto__ === Function.prototype) //true
	// console.log(C.prototype.__proto__ === Object.prototype) //true

	// class C extends null {
	// 	constructor() {
	// 		// super()
	// 		return Object.create(null)
	// 	}
	// }
	// var c = new C()
	// console.log(C.__proto__ === Function.prototype) //true
	// console.log(C.prototype.__proto__ === undefined) //true
</script>
</body>
</html>
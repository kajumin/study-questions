<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- 额外: .then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 -->

<!-- 尚硅谷 -->
<!-- 
	几个关键的问题
1. 改变promise对象的状态
  (1)resolve (2)reject  (3)抛出异常(任意类型) rejected状态
  状态一旦改变后就不会再变, 任何时候都可以得到这个结果

2. 一个promise指定多个成功或者失败的回调函数, 都会调用吗?  
  都会调用

3. 改变promise状态和指定回调函数谁先谁后?
 常规: 先指定回调函数, 后改变状态
 (1)先指定回调函数, 保存当前指定的回调函数, 后改变状态, 异步执行回调函数 
 (2)先改变状态, 后指定回调函数, 异步执行回调函数
 (3)方法二: 先改变状态, 后指定回调函数, 异步执行回调函数 
  .then是指定回调函数(同步), 回调函数才是异步

4. .then指定回调函数, 回调函数返回新promise对象结果状态由什么决定, 实现链式调用
    (1) 由.then指定回调函数的执行结果决定
  		  1.return 2  任意数据类型  成功状态
        2.throw  "错误 2"  任意数据类型  失败状态
 		    3.return Promise.resolve(2)  Promise.reject("错误 2") 返回promise对象
    (2) 默认返回的promise对象是成功状态的 结果为: undefined

5. promise串连多个任务, 
   同步通过return直接返回结果,
   异步return一个promise对象中的resolve返回结果

6. 异常传透 |穿透问题
  当使用promise的then链式调用时, 可以在最后指定失败的回调
  前面的任何操作异常都会传到最后失败的回调中处理

  原理: 前面没有.catch回调函数, 相当于 reason => { throw reason } 或者 reason => Promise.reject(reason)
  
7. 中断promise链式调用, 返回一个pending状态的promise
   当不想执行后面的回调函数时, 中断链式调用
   return new Promise(() => {})
-->
 <script type="text/javascript">
 	const p1 = new Promise((resolve, reject) => {
 		// resolve(1)
 		// reject(2)
 		// 可以抛出任意类型
 		throw 3
 		throw '出错了'
 		throw { message: '错误' }
 		throw new Error('出错了')
 	})
 	p1.then(res => {
 		console.log(res)
 	})
 	.catch(err => {
 		console.log(err)
 	})

 	const p2 = new Promise((resolve, reject) => {
 		resolve(2)
 	})
 	p2.then(res => {
 		console.log(res)
 	})
 	.catch(err => {
 		console.log(err)
 	})
 	p2.then(res => {
 		console.log(res)
 	})
 	.catch(err => {
 		console.log(err)
 	})

	
 	const p3_1 = new Promise((resolve, reject) => {
 		setTimeout(() => {
 			resolve(3)
 		}, 1000)
 	})
 	p3_1.then(res => {
 		console.log(res)
 	})
 	.catch(err => {
 		console.log(err)
 	})

 	const p3_2 = new Promise((resolve, reject) => {
 		resolve(3)
 	})
 	p3_2.then(res => {
 		console.log(res)
 	})
 	.catch(err => {
 		console.log(err)
 	})

 	const p3_3 = new Promise((resolve, reject) => {
 		setTimeout(() => {
 			resolve(3)
 		}, 1000)
 	})
 	setTimeout(()=>{
		p3_3.then(res => {
	 		console.log(res)
	 	})
	 	.catch(err => {
	 		console.log(err)
	 	})
 	}, 2000)

 	const p4 = new Promise((resolve, reject) => {
 		resolve(4)
 		// reject("4 出错了")
 	})
 	p4.then(res => {
 		console.log(res)
 		return Promise.resolve(44)
 		return Promise.reject("44 错误")
 		throw 5
 	})
 	.catch(err => {
 		console.log(err)
 	})
 	.then(res => {
 		console.log(res) //undefined
 	})
 	.catch(err => {
 		console.log(err)
 	})

 	const p5 = new Promise((resolve, reject) => {
 		setTimeout(() => {
 			console.log("执行任务1(异步)")
 			resolve(5)
 		}, 1000)
 	})
 	p5.then(res => {
 		console.log("任务1(结果)", res)
 		console.log("执行任务2(同步)")
 		return 55
 	})
 	.then(res => {
 		console.log("任务2(结果)", res)
 		return new Promise((resolve,reject) => {
 			setTimeout(()=>{
				console.log("执行任务3(异步)")
				resolve(555)
 			},0 )
 		})
 	})
 	.then(res => {
 		console.log("任务3(结果)", res)
 	})

 	const p6 = new Promise((resolve, reject) => {
 		setTimeout(() => {
 			// resolve(6)
 			reject("错误 6")
 		}, 1000)
 	})
	p6.then(res => {
 		console.log(res)
 		return 66
 	})
 	.then(res => {
 		console.log(res)
 		return 666
 	})
 	.catch(err => {
 		console.log(err)
 	})

 	const p7 = new Promise((resolve, reject) => {
 		setTimeout(() => {
 			// resolve(7)
 			reject("错误 7")
 		}, 1000)
 	})
	p7.then(res => {
 		console.log(res)
 		return 77
 	})
 	.then(res => {
 		console.log(res)
 		return 777
 	})
 	.catch(err => {
 		console.log(err)
 	})
 	.then(res => {
 		console.log(res)
 	})



 	
 	



 </script>
</body>
</html>
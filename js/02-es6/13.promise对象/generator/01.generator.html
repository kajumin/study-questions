<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- 
generator函数 是分段执行的, yield是暂停的标记, next方法可以恢复执行

一种异步编程解决方案, 从语法上说, 可以把它理解成一个状态机, 封装了多个内部状态, 执行generator函数会返回一个遍历器对象,
除了是状态机, 还是一个遍历器对象生成函数, 返回的遍历器对象可以依次遍历
generator函数内部的每一个状态

特征: 
(1)function和函数名之间有一个星号*
(2)函数体内部使用yield语句定义不同的内部状态

1.yield表达式 暂停的标志, 调用next方法
return值也会输出
不能在普通函数中使用
另一个表达式中加括号

2.与iterator接口的关系
   使用generator函数作为对象的iterator接口
3.next方法的参数
  作为上一次yield语句的返回值, 注入不同的值, 调整函数行为

4.for...of: 可以用来遍历generator函数返回的遍历器对象
  扩展运算符 Array.from 解构赋值 但是return的值不会计算在内

5.Generator.prototype.throw()
  函数体外抛出错误, 函数体内捕获
  函数体内抛出错误, 也可以在函数体外捕获
  区别于全局throw, 只能catch捕获

6.Generator.prototype.return 
  可以返回给定的值, 并终止generator函数的遍历
-->
<script>
	function* gen() {
		// 第一次调用next方法 返回一个对象value属性值为hello done属性值为false
		yield 'hello'
		// 第二次调用next方法 返回一个对象value属性值为world done属性值为false
		yield 'world'
		// 第三次调用next方法 返回一个对象value属性值为ending done属性值为true
		// return 'ending'
	}
	var g = gen()
	console.log(g.next()) //hello
	console.log(g.next()) //world
	console.log(g.next()) //return值, 没有则为undefined


	const obj = {
		[Symbol.iterator]: function* (){
			yield 1
			yield 2
			yield 3
		}
	}
	for(var o of obj) {
		console.log(o)
	}

	function* foo(x) {
		var y = 2 * (yield x * 2)
		var z = yield (y/3)
		// console.log(x)
		// console.log(y)
		// console.log(z)
		return x + y + z
	}
	var f = foo(1)
	// console.log(f.next()) //2
	// console.log(f.next()) //NaN
	// console.log(f.next()) //NaN

	console.log(f.next()) //2
	console.log(f.next(12)) //8
	console.log(f.next(13)) //38 = 1 + 24 + 13

	// 4.
	function* numbers() {
		yield 1
		yield 2
		return 3
		yield 4
	}
	console.log([...numbers()])
	console.log(Array.from(numbers()))
	const [a, b] = numbers()
	console.log(a, b)

	// 6.
	function* gen2() {
		yield 11
		yield 22
		yield 33
	}
	var g2 = gen2()
	console.log(g2.next())
	// console.log(g2.return()) //undefined
	console.log(g2.return('4')) //4

</script>
</body>
</html>
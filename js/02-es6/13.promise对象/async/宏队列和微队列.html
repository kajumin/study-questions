<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<div id="box1">中国</div>
<!-- 
异步任务分为宏任务和微任务.
队列: 宏队列和微队列   宏队列可以有多个 微队列只有一个
宏任务: setTimeout setInterval dom事件回调 ajax回调
微任务: promise.then process.nextTick mutationObserver queueMicrotask
mutationObserver 是一个可以监听DOM结构变化的接口。
 -->
<script type="text/javascript">
	// promise何时加入到微队列中?
	// (1).then指定回调函数时且promise状态已经改变
	// (2)promise状态改变时且已经指定回调函数
	// new Promise((resolve, reject) =>{
	// 	setTimeout(() => {
	// 		resolve(1)
	// 	})
	// 	new Promise(resolve => {
	// 		resolve(2)
	// 	})
	// 	.then(res => console.log(res))
	// })
	// .then(res => console.log(res))
	
	// new Promise(resolve => {
	// 	resolve(3)
	// })
	// .then(res => {
	// 	console.log(res)
	// })
	// 2 1  说明.then才将任务放到任务队列中, 因为改变状态的时候回调函数没有指定
</script>
 <script type="text/javascript">
 	//选择一个需要观察的节点
	var targetNode = document.getElementById('box1');
	console.log(targetNode)
	// 设置observer的配置选项
	var config = { attributes: true, childList: true, subtree: true };

	// 当节点发生变化时的需要执行的函数
	var callback = function(mutationsList, observer) {
		console.log(mutationsList)
		console.log(observer)
	    for(var mutation of mutationsList) {
	        if (mutation.type == 'childList') {
	            console.log('A child node has been added or removed.');
	        }
	        else if (mutation.type == 'attributes') {
	            console.log('The ' + mutation.attributeName + ' attribute was modified.');
	        }
	    }
	};
	// 创建一个observer示例与回调函数相关联
	var observer = new MutationObserver(callback);
	// 使用配置文件对目标节点进行观测
	observer.observe(targetNode, config);
	// 停止观测
	// observer.disconnect();

	Promise.resolve(1).then(res => console.log(res))
	targetNode.append('<p>123<p>')
	targetNode.setAttribute('class', 'box1')
	Promise.resolve(2).then(res => console.log(res))
	console.log('script end')
	// script end 1 mutationObserver 2
 </script>
</body>
</html>
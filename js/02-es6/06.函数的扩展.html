<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
/*
	1.参数的默认值: undefined才会触发 传统方法: 对应布尔值为false就触发
	与解构赋值结合使用
	参数默认值的位置
	fun.length属性: 除了默认参数和rest参数的形参数量(默认参数之后的也不计算)
	作用域: 参数形成一个单独的作用域
	var x = 1
	function(x = x) {} //报错  相当于let x = x 暂时性死区

	2.rest参数

	3.严格模式: 函数使用默认值 解构赋值 扩展运算符
		不能显式指定严格模式

	4.name属性
		foo:  函数表达式和函数声明都返回正确的函数名
		anonymous: Function构造函数
		bind foo: bind返回的函数

	5.箭头函数
	(1)函数体内的this对象就是定义时所在的对象, 不是使用时所在的对象
	(2)不可以使用arguments对象, 改用rest参数
	(3)不可以当做构造函数, 不能使用new命令
	(4)不可以当做generator函数, 不能使用yield命令
	(5)apply call bind对箭头函数无效

	6.绑定this对象 bind apply bind

	7.尾调用优化
		函数调用会在内存中形成一个调用记录, 又称为调用帧, 保存调用的位置和内部变量等信息,
		如果在A中调用B, 那个A上方又会形成一个B的调用帧, 等B运行结束, 返回结果到A, B的调用帧
		才会消失. 所有的调用帧就形成了调用栈
		
		尾递归: 阶乘函数 斐波那契数列 curry(柯里化函数)
		递归函数改写
*/
	const arr = [1, 2, 3]
	console.log(arr.push(10, 11, 12)) //添加一个或多个值 返回长度

	// 阶乘函数
	function factorial(n) {
		if(n === 1) return n
		return n * factorial(n - 1)
	}
	function factorial2(n, total) {
		if(n === 1) return total
		return factorial2(n - 1, n * total)
	}
	console.log(factorial(5));
	console.log(factorial2(5, 1));

	// 斐波那契数列
	function fibonacci(n) {
		if(n <= 1) return 1
		return fibonacci(n - 1) + fibonacci(n - 2)
	}
	console.log(fibonacci(10));//89
	// console.log(fibonacci(100)); 运算不了

	function fibonacci2(n, ac1 = 1, ac2 = 1) {
		if(n <= 1) return ac2
		return fibonacci2(n -1, ac2, ac1 + ac2)
	}
	console.log(fibonacci2(10)); //89
	console.log(fibonacci2(100)); //可以调用

	// 改写factorial3
	function factorial3(n, total) {
		if(n === 1) return total
		return factorial3(n - 1, n * total)
	}
	function toFactorial(n) {
		return factorial3(n, 1)
	}
	console.log(toFactorial(5));

	// 使用柯里化
	function curry(fn, n) {
		return function(m) {
			return fn.call(this, m, n)
		}
	}
	var curryFactorial = curry(factorial3, 1)
	console.log(curryFactorial(5));

	// es6默认值
	function factorial4(n, total=1) {
		if(n === 1) return total
		return factorial2(n - 1, n * total)
	}
	console.log(factorial4(5));

	const curry2 = function(fn) {
		return function judge(...args) {
			console.log(fn.length, args.length);		
			if(fn.length === args.length) {
				// 参数够了, 直接执行, 参数传递进行
				return fn(...args)
			} else {
				// 参数数量不够 返回一个接受参数的函数, 继续添加参数数量
				return function(...arg) {
					return judge(...args, ...arg)
				}
			}
		}
	}

	function sum(a, b, c, d) {
		console.log(a + b + c + d); //4
	}
	const currySum = curry2(sum)
	currySum(1)(1)(1)(1)
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- 
	1.将Object对象明显属于内部的方法
	2.修改默写Object方法的放回结果  如: defineProperty()  返回false
	3.让Object操作都变成函数行为
	  Reflect.has(Object, 'assign')
	4.
	  Function.prototype.apply.call(Math.floor, undefined, [1.75])
	  Reflect.apply(Math.floor, undefined, [1.75])
-->
<script type="text/javascript">
	var obj = {}
	var loggedObj = new Proxy(obj, {
		get(target, name) {
			console.log('get:', target, name)
			return Reflect.get(target, name)
		},
		deleteProperty(target, name) {
			console.log('delete:', target, name)
			return Reflect.deleteProperty(target, name)
		},
		has(target, name) {
			console.log('has:', name)
			return Reflect.has(target, name)
		}
	})
	loggedObj.count
	delete loggedObj.count
	Reflect.has(loggedObj, 'assign')
</script>
</body>
</html>
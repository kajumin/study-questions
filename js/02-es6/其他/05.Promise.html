<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p>123</p>
<!-- 
Promise 是异步编程的一种解决方案, Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。
特点: 
 (1）对象的状态不受外界影响, 有三种状态: pending（进行中）、fulfilled（已成功）和rejected（已失败）
（2）一旦状态改变, 就不会再变, 任何时候都可以得到这个结果。

将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外,Promise对象提供统一的接口,使得控制异步操作更加容易。

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”
reject函数的作用是， 将Promise对象的状态从“未完成”变为“失败”
可以将信息作为参数传递出去。

原型上方法.then  获取成功回调的信息
         .catch 获取失败回调的信息
静态方法: 
Promise.all()的作用是接收一组异步任务，然后并行执行异步任务，并且在所有异步操作执行完后才执行回调。
(1) 所有异步任务状态都为成功状态, 才会执行.then回调
(2) 异步任务中有一个状态为失败状态, 就会执行.catch回调  第一个rejected的返回值就会传递给回调函数, 除非它自身有.catch错误处理

Promise.race()的作用是接收一组异步任务,然后并行执行异步任务，只要有一个率先改变状态就会执行回调并将返回值传递出去。
eg: 如果不是任务, 会通过Promise.resolve()转为promise对象
 -->
 <!-- 
 	Promise.resolve()的作用将现有的对象转化为promise对象
 	(1) 参数是promise对象, 不做任何修改, 直接返回
 	(2) 参数是一个thenable对象, 转化为promise对象, 并立即执行thenable对象中的.then方法
 	(3) 不带任何参数, 返回一个状态为resolved的promise对象
 	(4) 原始值, 返回一个状态为resolve的promise对象, 参数也会被传递给该promise对象的回调参数 
 -->
 <!-- 
 	Promise.reject()的作用将现有的对象转化为promise对象
 	参数会原封不动地作用reject的理由传递回调函数
 -->
  <!-- 
 	finally回调函数不管状态是成功还是失败都会执行
 -->

<script type="text/javascript">
 	
</script>
<script type="text/javascript">

	console.log(Promise.resolve(new Promise(r => r('123'))))//Promise {<resolved>: "123"}
	console.log(Promise.resolve('123')) //Promise {<resolved>: "123"}
	console.log(Promise.resolve()) //Promise {<resolved>: undefined}
	
	console.log(Promise.reject(new Promise(r => r('123')))) //Promise {<rejected>: Promise}
	console.log(Promise.reject()) //Promise {<rejected>: undefined}
	console.log(Promise.reject('123')) //Promise {<rejected>: "123"}

	Promise.reject(new Promise(r => r('123'))).
	then(res => {
	})
	.catch(res => {
		console.log(res) // Promise {<resolved>: "123"}
		res.then(res2 => {
			console.log(res2) // 123
		})
	})

	function loadImageAsync(url) {
		 return new Promise(function(resolve, reject) {
		    const image = new Image();

		    image.onload = function() {
		      resolve(image);
		    };

		    image.onerror = function() {
		      reject(new Error('Could not load image at ' + url));
		    };

		    image.src = url;
	  	})
	}
	var url = '../../images/1.jpg'
	console.log(url)
	loadImageAsync(url)
	.then(res => {
		console.log(res)
		document.body.appendChild(res)
	})

	const getJSON = function(url) {
	  	const promise = new Promise(function(resolve, reject){
	    const handler = function() {
	      	if (this.readyState !== 4) {
	        	return;
	      	}
	      	if (this.status === 200) {
	       	 	resolve(this.response);
	      	} else {
	       		reject(new Error(this.statusText));
	      	}
	    };
	    const xhr = new XMLHttpRequest();
	    xhr.open("GET", url);
	    xhr.onreadystatechange = handler;
	    xhr.responseType = "json";
	    xhr.setRequestHeader("Accept", "application/json");
	    xhr.send();

	});
	  	return promise;
	};

	getJSON("/posts.json").then(function(json) {
	  	console.log('Contents: ' + json);
	}, function(error) {
	  	console.error('出错了', error);
	});
</script>
</body>
</html>
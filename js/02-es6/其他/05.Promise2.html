<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<script type="text/javascript">
	const p1 = new Promise(function (resolve, reject) {
	  setTimeout(() => reject(new Error('fail')), 3000)
	})

	const p2 = new Promise(function (resolve, reject) {
	  setTimeout(() => resolve(p1), 1000)
	})

	p2
	.then(result => console.log(result))
	.catch(error => console.log(error))
	// Error: fail

	// 调用resolve或reject并不会终结 Promise 的参数函数的执行。
	// resolved 的 Promise 是在本轮事件循环的末尾执行 所以先打印2
	new Promise((resolve, reject) => {
	  	resolve(1);
	 	 console.log(2);
	}).then(r => {
	  	console.log(r);
	});
	// 2
	// 1

	// Promise.prototype.then
	// Promise.prototype.catch
	// Promise.prototype.finally
	// getJSON("/post/1.json").then(
 //  		post => getJSON(post.commentURL)
	// ).then(
 //  		comments => console.log("resolved: ", comments),
 //  		err => console.log("rejected: ", err)
	// );

	// Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。

	// finally() 在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。


	// Promise.all    方法是将多个 Promise 实例，包装成一个新的 Promise 实例。
	// Promise.race() 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。

	// Promise.all
    // (1)只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
    // (2)只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

	// 如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。
	const p3 = new Promise((resolve, reject) => {
	  resolve('hello');
	})
	.then(result => result)
	.catch(err => {
		console.log(err)
	});

	const p4 = new Promise((resolve, reject) => {
	  throw new Error('报错了');
	})
	.then(result => result)
	.catch(err => err);

	Promise.all([p3, p4])
	.then(result => console.log(result))
	.catch(e => console.log(e));
	// ["hello", Error: 报错了]
	// p2有自己的错误处理, 返回新的promise对象  所以两个都是resolved
	// 执行all.then()成功回调

	// Promise.resolve()
	// Promise.reject()
	// Promise.resolve('foo')
	// 等价于
	// new Promise(resolve => resolve('foo'))
	
	
	// const p5 = Promise.reject('出错了');
	// 等同于
	const p5 = new Promise((resolve, reject) => reject('出错了'))

	p5.then(null, function (s) {
	  console.log(s)
	});
	// // 出错了
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!--
	proxy: 用于修改某些操作的默认行为, 可以理解成在目标对象前架设一个"拦截"层, 外界对该对象的访问都必须先通过这层拦截, proxy原意为代理, 用在这里表示由它来"代理"某些操作,可译为 "代理器"
	第一个参数: 要代理的目标对象
	第二个参数: 是一个配置对象, 对于每一个被代理的操作, 需要提供一个对应的处理函数, 该函数将拦截对应的操作
  -->
  <!-- 
	拦截器
	(1)get set
	(2)apply

   -->
<script type="text/javascript">
	var obj = new Proxy({}, {
		get: function (target, key, receiver) {
			console.log(`getting ${key}`)
			return Reflect.set(target, key, receiver)
		},
		set: function (target, key, value, receiver) {
			console.log(`setting ${key}`)
			return Reflect.get(target, key, value, receiver)
		}
	})
	obj.count = 1
	++obj.count

	// 除了get set拦截器
	// 还有: 
	// (1)apply方法拦截函数的调用、call和apply操作。  apply (target, ctx, args) {}
	// apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组
	// (2)has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
	// 	has方法可以接受两个参数，分别是目标对象、需查询的属性名。
	// (3)construct方法用于拦截new命令，下面是拦截对象的写法。
		// construct方法可以接受三个参数。target：目标对象args：构造函数的参数对象newTarget：创造实例对象时，new命令作用的构造函数
	// (4)deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 deleteProperty (target, key) {}
	// (5)defineProperty()方法拦截了Object.defineProperty()操作。
	// defineProperty (target, key, descriptor) {}
	// (6)getOwnPropertyDescriptor()方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。
	   // getOwnPropertyDescriptor (target, key) {}

	// (7)getPrototypeOf()方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。
	// Object.prototype.__proto__
	// Object.prototype.isPrototypeOf()
	// Object.getPrototypeOf()
	// Reflect.getPrototypeOf()
	// instanceof

	// (8)isExtensible()方法拦截Object.isExtensible()操作。
	// (9)ownKeys()方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。
	// Object.getOwnPropertyNames()
	// Object.getOwnPropertySymbols()
	// Object.keys()
	// for...in循环
	// (10)preventExtensions()方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。
	// deleteProperty(targe, propKey)
	// (11)setPrototypeOf()方法主要用来拦截Object.setPrototypeOf()方法。
	// (12)Proxy.revocable()方法返回一个可取消的 Proxy 实例。  

	
	// this问题 proxy可以代理针对目标对象的访问, 但它不是目标对象的透明代理, 则不做任何拦截的情况下无法保证与目标对象的行为一直, 目标对象内部的this关键字会指向proxy代理

	var Person = { name: 'bang', age: 18 }
	let person = new Proxy(Person, {
        get(target, key){
            return target[key];
        
        },
        set(target, key, value) {
            // if(key != "sex"){  //只保护了sex属性
            //     target[key] = value;
            // } 
            // 如果没有任何东西  任何数据都不能改
            // 如果有可以改变Person中的数据
        }
    });
    person.name = 'joycechu' //不能修改
    console.log(person)

</script>
</body>
</html>
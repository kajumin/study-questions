<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<!-- 
	1.typeof bar === 'object'存在的问题
	2.var a = b = 3  b会变成全局变量 严格模式下
	Uncaught ReferenceError: b is not defined
	Uncaught TypeError: b is not a function
	3.this指向问题
	4.在功能块中封装JavaScript源文件的全部内容的重要性和原因是什么？
	  (1)创建一个私有名称空间，从而有助于避免不同JavaScript模块和库之间的潜在名称冲突
	  (2)为全局变量提供一个容易引用（可能更短）的别名
	5.use strict
	  一种在运行时自动执行更严格的JavaScript代码解析和错误处理的方法
	  使调试更容易(错误被忽略) 意外全局 重复参数 无效的删除符 
	6.return 返回值不一样
	7.NaN判断
	  NaN属性表示“不是数字”的值
	8.0.1 + 0.2  0.1 + 0.2 == 0.3
	  JavaScript中的数字全部用浮点精度处理，因此可能不会总是产生预期的结果
	  es6: Number.EPSILON极小的常量 一个可接受的误差范围
	9.setTimeout输出顺序问题
	10.判断回文函数
	11.两种sum调用方式
	14.输出结果 [[1,2]].toString() -> 1,2
	20.严格相等 和 宽松相等
	21.对象只接受字符串为属性
	25.dom及其子元素, 执行回调函数 ele.children
	27.this丢失 指向arguments时 .length输出形参数量
	28.变量提升, 即使在try catch代码块中
	34.数组空位输出为undefined map保留空位
	 -->
<script>
	// typeof判断一个对象
	var nu = null
	console.log(typeof nu === 'object')
	// 修复null问题
	console.log(typeof nu === 'object' && nu !== null)
	// 修复function问题
	function fn() {

	}
	console.log((typeof fn === 'object' || typeof fn === 'function') && fn !== null )

	// 排除数组
	var arr = []
	console.log(arr !== null && typeof arr === "object" && (toString.call(arr) !== "[object Array]"))


	;(function(){
		// 'use strict'
		// Uncaught ReferenceError: b is not defined
		var a = b = 1
		var aaa = null
		var aaa = undefined
	})()
	console.log(typeof a)
	console.log(typeof b)
	// b()
	//Uncaught TypeError: b is not a function

	var myObject = {
    	foo: "bar",
    	func: function() {
	        var self = this;
	        console.log(this.foo); //bar
	        console.log(self.foo); //bar
	        (function() {
	            console.log(this.foo); //undefined
	            console.log(self.foo); //bar
	        }());
    	}

	};
	myObject.func();


	function foo1(){
		return {
		    bar: "hello"
		  };
	}

	function foo2(){
	  	return
	  	{
	    	bar: "hello"
	 	};
	}
	console.log(foo1())
	console.log(foo2())


	// 8.0.1 + 0.2 == 0.3
	function areTheNumbersAlmostEqual(num1, num2) {		
    	return Math.abs( num1 - num2 ) < Number.EPSILON;
	}
	console.log(areTheNumbersAlmostEqual(0.1 + 0.2, 0.3));

	function isInteger(x) { return (x ^ 0) === x; }
	console.log(isInteger(1))
	console.log(isInteger(1.2))
	// round ceil floor
	function isInteger2(x) { return Math.floor(x) === x; }
	console.log(isInteger2(1))
	console.log(isInteger2(1.2))
	function isInteger3(x) { return (typeof x === 'number') && (x % 1 === 0); }
	console.log(isInteger3(1))
	console.log(isInteger3(1.2))

	// 10.回文字符串
	function reback(str) {
		str = str.replace(/\W/g, '').toLowerCase()
		return str === str.split('').reverse().join('')
		console.log(str)
	}
	console.log(reback('abc cba'))

	// 11.两种sum调用方式
	function sum(x) {
		if(arguments.length === 2) {
			return arguments[0] + arguments[1]
		}else {
			return function(y) {
				return x + y
			}
		}
	}
	function sum2(x, y) {
		if(typeof y === 'undefined') {
			return function(y) {
				return x + y
			}
		}else {
			return x + y
		}
	}

	console.log(sum(1, 2))
	console.log(sum(1)(2))
	console.log(sum2(1, 2))
	console.log(sum2(1)(2))

	// 12.动态添加按钮
	// for (var i = 0; i < 5; i++) {
 //  		var btn = document.createElement('button');
 //  		btn.appendChild(document.createTextNode('Button ' + i));
 //  		btn.addEventListener('click', function() {
 //    		console.log(i);
 //  		});
	// 	document.body.appendChild(btn);
	// }
	// 利用闭包
	// for (var i = 0; i < 5; i++) {
 //  		var btn = document.createElement('button');
 //  		btn.appendChild(document.createTextNode('Button ' + i));
 //  		btn.addEventListener('click', (function(i) {
 //    		return function() { console.log(i); };
 //  		})(i));

 // 	 	document.body.appendChild(btn);
	// }
	// for (var i = 0; i < 5; i++) {
 //  		var btn = document.createElement('button');
 //  		btn.appendChild(document.createTextNode('Button ' + i));
 //  		(function(i) {
 //  			btn.addEventListener('click', function() {
 //    			console.log(i)
 //    		})
 //  		})(i);
 // 	 	document.body.appendChild(btn);
	// }

	// for (let i = 0; i < 5; i++) {
 //  		var btn = document.createElement('button');
 //  		btn.appendChild(document.createTextNode('Button ' + i));
 //  		btn.addEventListener('click', function() {
 //    		console.log(i);
 //  		});
	// 	document.body.appendChild(btn);
	// }

	// 13.输出undefined
	var d = {};
	['zebra', 'horse'].forEach(function(k) {
    	d[k] = undefined;
	});
	console.log(d)

	// 14. 输出结果
	var arr1 = "john".split('');
	var arr2 = arr1.reverse();
	var arr3 = "jones".split('');
	arr2.push(arr3);

	console.log(arr1.slice(-1))
	console.log(arr1.length, '' + arr1.slice(-1))
	console.log(arr2.length, '' + arr2.slice(-1))

	console.log([1,2].toString())
	console.log([[1,2]].toString())

	console.log(1 + "2" + "2");  //122
	console.log(1 + +"2" + "2"); //32
	console.log(1 + -"1" + "2"); //02
	console.log(+"1" + "1" + "2"); //112
	console.log( "A" - "B" + "2"); //NaN2
	console.log( "A" - "B" + 2); //NaN

	// 16.数组项太多, 递归堆栈溢出, 则将超时函数（nextListItem）推送到事件队列，并且函数退出，从而使调用堆栈清零
	var list = new Array(100000).fill(1)
	var nextListItem = function() {
   	 	var item = list.pop();
   	 	console.log(item)
    	if (item) {
        	// process the list item...
        	setTimeout(nextListItem, 0);
    	}
	};
	// nextListItem()

	// 17.闭包例子
	var globalVar = 'xyz'
	;(function outerFunc(outerArg) {
		var outerVar = 'a'
		;(function(innerArg) {
			var innerVar = 'b'
			console.log(outerArg)
			console.log(innerArg)
			console.log(outerVar)
			console.log(innerVar)
			console.log(globalVar)
		})(456)
	})(123)

	// 18.for setTimeout输出循环变量  5555
	// 19.|| && 

	// 20.严格相等 和 宽松相等
	console.log(false == '0') //true
	console.log(false === '0') //false

	// 21.对象只接受字符串为属性
	var a = {},
    	b = {key:'b'},
    	c = {key:'c'};
	a[b] = 123;
	a[c] = 456;
	console.log(a)
	console.log(a[b])

	// 22.10的阶乘
	console.log((function f(n){ return ((n > 1) ? n * f(n-1) : n) })(10));

	// 23.闭包问题
	(function(x) {
    	return (function(y) {
        	console.log(x);
    	})(2)

	})(1);
	// 24.this丢失问题
	var hero = {
	  	 _name: 'John Doe',
	    getSecretIdentity: function (){
	        return this._name;
	    }
	};
	var stoleSecretIdentity = hero.getSecretIdentity;
	console.log(stoleSecretIdentity());
	console.log(hero.getSecretIdentity());

	// 25.dom及其子元素, 执行回调函数 ele.children
	function Traverse(p_element,p_callback) {
   		p_callback(p_element);
   		var list = p_element.children;
   		for (var i = 0; i < list.length; i++) {
       		Traverse(list[i],p_callback); // recursive call
   		}	
	}

	// 27.this指向问题
	var length = 10;
	function fn() {
	    console.log(this.length);
	}
	var obj = {
	  length: 5,
	  method: function(fn) {
	    fn(); //10 this指向全局对象
	    arguments[0](); //2(参数的个数) this指向arguments对象
	  }
	};
	obj.method(fn, 1);

	// 28. 变量提升, 即使在try catch代码块中
	(function () {
		// 变量提升, 即使在try catch代码块中
	    try {
	        throw new Error();
	    } catch (x) {
	    	// 改为let会报错
	        var x = 1, y = 2;
	        console.log(x);
	    }
	    console.log(x);
	    console.log(y);
	})();
	// 29.变量提升
	// 30.克隆对象 Object.assign()
	// 31.for循环 setTimeout输出循环变量
	// 32.隐式转换 比较运算符
	console.log(1 < 2 < 3);
	console.log(3 > 2 > 1);
	// 33.数组方法 push unshift
	// 34.数组空位输出为undefined map保留空位
	// 34.
	var arr = [1, 2, 3]
	arr[10] = 99
	console.log(arr[6])
	var newArr = arr.map(() => 7)
	console.log(newArr)

	// 35.typeof问题
	console.log(typeof undefined == typeof NULL)
	// 36.typeof问题
	console.log(typeof typeof 1)

	var b = 1;
	// 37.闭包问题
	function outer(){
       	var b = 2
    	function inner(){
        	b++;
        	console.log(b) //undefined
        	var b = 3;
        	console.log(b) //3
    	}
    	inner();
	}
	outer();
</script>
</body>
</html>
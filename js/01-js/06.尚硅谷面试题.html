<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <!-- 
    1.作用域  函数参数传值
    2.字符串变成驼峰命名法
    3.冒泡排序
    4.数组反转
    5.原型链
    6.node事件循环机制
    7.执行上下文
    8.宏任务和微任务

   -->
  <script>
    // 作用域 基本数据类型函数参数传递
    (function() {
      var num1 = 55;
      var num2 = 66;

      function f1(num, num1) {
        num = 100
        num1 = 100
        num2 = 100
        console.log(num); //100
        console.log(num1); //100
        console.log(num2); //100
      }

      f1(num1, num2)
      console.log(num1); //55
      console.log(num2); //100
      // console.log(num); //报错
    })();
    // 引用类型的参数传递
    (function() {
      function Person(name, age, salary) {
        this.name = name
        this.age = age
        this.salary
      }
      function f1(person) {
        person.name = 'lyt'
        person = new Person('joycechu', 18, 2000)
        console.log(person.name); //joycechu
      }

      var p = new Person('bang', 20, 1000)
      console.log(p.name); //bang
      
      f1(p)
      console.log(p.name);//lyt
    })();
    // 转为驼峰命名法
    (function() {
      var str = 'get-element-by-id'
      function transformStr(str) {
        var arr = str.split('-')
        var result = ''
        arr.forEach(function(val, index) {
          if(index === 0) {
            result += val
          } else {
            result += val.charAt(0).toUpperCase() + val.slice(1)
          }
        })

        return result
      }
      console.log(transformStr(str))
    })();
    // 冒泡排序
    (function() {
      var arr = [1,2,4,5,8,7,8,9]

      for(var i = 0, len = arr.length; i < len; i++) {
        for(var j = 0; j < len - 1 - i; j++) {
          if(arr[j] > arr[j+1]) {
            var temp = arr[j]
            arr[j] = arr[j+1]
            arr[j+1] = temp
          }
        }
      }
      console.log(arr);
    })();
    // 数组反转
    (function() {
      var arr = [1,2,4,5,8,7,8,9]

      for(var i = 0, len = arr.length; i < len / 2; i++) {
        var temp = arr[i]
        arr[i] = arr[len-1-i]
        arr[len-1-i] = temp
      }
      console.log(arr);
    })();

    // 原型链
    (function () {
      function Foo() {
        getName = function() { alert(1) }
        return this
      }
      Foo.getName = function() { alert(2) }
      Foo.prototype.getName = function() { alert(3) }
      getName = function() { alert(4) }

      Foo.getName() //2
      getName() //4
      Foo().getName() //1
      getName() //1
      new Foo.getName() //2
      new Foo().getName() //3
      new new Foo().getName() //3
    })();

    // node事件循环机制
    (function() {
      // process.nextTick(function() {
      //   console.log('nextTick');
      // })
      // setTimeout(function() {
      //   console.log('setTimeout');
      // })
      // setImmediate(function() {
      //   console.log('setImmediate');
      // })
      // new Promise((resolve, reject) => {
      //   resolve('promise');
      // })
      // .then(res => {
      //   console.log(res);
      // })
      // nextTick
      // promise
      // setTimeout
      // setImmediate

      /* node.js事件轮询阶段: 借助libuv实现的
        **注意: process能在任意阶段优先执行
        1.timer阶段  定时器阶段
          计时和执行到点的定时器回调函数
        2.pending callback
          某些系统操作()的回调函数
        3.idle prepare
          准备工作
        4.poll轮询阶段 (轮询队列)
          如果轮询不为空, 依次同步去除轮询队列中的第一个回调函数执行, 直到轮询队列为空或到达系统最大的限制
          如果为空, 
            (1)如果之前设置setImmediate函数, 直接进入下一个check阶段
            (2)如果没有设置过setImmediate函数, 在当前poll阶段等到, 
                (1)直到轮询队列添加回调函数, 
                (2)如果定时器到点了, 也会去下一个阶段
        5.check阶段 查询阶段
          setImmediate设置的回调函数
        6.close callback 关闭阶段
         执行close事件的回调函数

      */
    })();

    (function() {
      /* 
        变量提升: 
        js引擎在执行代码之前会做一个预处理的工作
        1.收集变量  定义但不赋值
        2.收集函数  提前定义该函数

        执行上下文: 执行上下文环境
        理解: 代码执行的环境
        时机: 代码正式执行之前会进入到执行上下文环境
        工作: 
          1.创建变量对象
            1)变量
            2)函数及函数的参数
          2.确定this指向  全局this->window  调用其的对象
          3.创建作用域链 父级作用域链 + 当前作用域

          4.扩展: ECOBJ = { 
            变量对象: {变量 函数 函数的形参}
            scopeChain 作用域链
            this: {全局对象window || 调用其的对象}
          }

      */
    })();

    (function() {
      /* 
      
      放入事件队列里面才会被执行
      宏任务(多个队列): setTimeout setInterval script全局整体代码
      微任务(一个队列): promise.then process.nextTick MutationObserve

      */
    })();
  </script>
</body>
</html>
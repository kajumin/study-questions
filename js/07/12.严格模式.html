<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- 
	严格模式同时改变了语法及运行时行为, 在严格模式下, 某些先前被接受的过失错误将会被认为是异常(报错),
	严格模式可以应用到整个脚本或个别函数中.

	1.严格模式下无法再意外创建全局变量 ReferenceError
	2.严格模式会使引起静默失败(不报错也没有任何效果)的赋值操作抛出异常
	  (1)writable: false修改
	  (2){ get x(){return 17} }给只读属性赋值
	  (3)不可扩展对象的新属性赋值 Object.preventExtensions(fixed);
	  
	3.在严格模式下, 试图删除不可删除的属性时会抛出异常(之前这种操作不会产生任何效果)
	4.严格模式要求一个对象内的所有属性名在对象内必须唯一
	5.严格模式要求函数的参数名唯一
	6.严格模式禁止八进制数字语法 0语法

	7.严格模式禁用with eval 删除声明变量

	8.eval arguments不能通过程序语法被绑定(be bound)或赋值
	  arguments中的值不会跟这参数的值而变化
      不再支持 arguments.callee  fun.caller fun.arguments

    9.在严格模式下通过this传递给一个函数的值不会被强制转换为一个对象
      非严格模式 null undefined -> window  number string boolean ->转为对应对象
      严格模式 null undefined number string boolean 都是这个值不会转换
-->
<script type="text/javascript">
	"use strict";
	// 给不可写属性赋值
	var obj1 = {};
	Object.defineProperty(obj1, "x", { value: 42, writable: false });
	// obj1.x = 9; // 抛出TypeError错误

	// 给只读属性赋值
	var obj2 = { get x() { return 17; } };
	// obj2.x = 5; // 抛出TypeError错误

	// 给不可扩展对象的新属性赋值
	var fixed = {};
	Object.preventExtensions(fixed);
	// fixed.newProp = "ohai"; // 抛出TypeError错误

	var o = { p: 1, p: 2 }; // !!! 语法错误
	console.log(o)

	console.log(0o644 === 420)

	// 函数参数唯一
	// function fun1(x, x) {
	// 	console.log(x)
	// }
	// fun1(1, 2)

	console.log(0o15 + 12)

	function fun2(a) {
		a = 20
		console.log(arguments)
		console.log(arguments[0])
		// console.log(arguments.callee)
		// console.log(a, arguments[0])
		function inner() {
			// console.log(inner.caller)
			// console.log(inner.arguments)
		}
		inner()
	}
	fun2(10)


	// 9.this不会强制转换为对象
	function fun9() {
		console.log(this)
	}
	fun9.call(null)
	fun9.call(undefined)
	fun9.call(12)
	fun9.call('abc')
	fun9.call(false)

	// "use strict"
	// function fun1 () {
	// 	// 全局严格模式和函数内部严格模式都是一样的
	// 	"use strict"
	// 	age = 21; //Uncaught ReferenceError: age is not defined
	// 	console.log(age)
	// }
	// fun1()
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<!-- 
	1. 闭包问题 修改函数
	2. this指向问题
	3. 具名自执行函数(IIFE)是只读的 无法修改 不会报错
	4. 函数this指向 -> window  严格模式 -> undefined 箭头函数 -> 都是window
	5. 惰性求值, 不会记录下来(即使是默认值求值)
	6. 默认值右边变量不影响代码块中定义变量名, 默认参数时产生独立独立作用域
	7. 回调函数不能获取调用时所在作用域的变量, 只能获取定义时所在作用域的变量
	   setTimeout可以获取调用时所在作用域的变量, 但是传递的函数不行setTimeout(cb,0)
	 -->
<script type="text/javascript">
	function A (a) {
		// 形成了闭包 不是A也会形成闭包  需要再次调用
		console.log(A)
		A = function (b) { //覆盖全局的函数A
			console.log(a + b++) //4
			// 2 + 2  b还没自增
		}
		console.log(a++) //闭包值永远等于2
	}
	A(1); //1
	A(2); //4
	A(2); //4

	console.log(`${(x=>x)('i love')} to program`); //i love to program
	// i love当做参数被传递

	var num = 10
	var obj = { num: 20 }
	obj.fn = (function(num) {
		// console.log(this) //window
		this.num = num * 3
		// window num = 60
		num++
		// num 21
		return function (n) {
			this.num += n
			// window 60 + 5
			// obj.num 20 + 10
			num++
			// num 22
			// num 23
			console.log(num)
		}
	})(obj.num)
	var f5 = obj.fn
	f5(5)
	obj.fn(10)
	console.log(obj.num, num)// 30 65

	function fun1() {
		console.log(this.name)
	}
	var obj = {
		name: 'bang',
		fun: fun1
	}
	obj.fun() //'bang'

	var b = 10;
	(function b() {
		// 非匿名自执行函数是只读的 无法修改
		// "use strict"//报错(对常量变量赋值) 所以无效 Assignment to constant variable.
		b = 20 //IIFE的函数无法进行复制(内部机制, 所以无效) 不会报错
		console.log(b) //fn
		console.log(window.b) //10
	})();

	var fun2 = () => { 
		"use strict"
		console.log(this) //window  不是箭头函数为undefined
	};
	fun2()


	// 惰性求值  不能记录下来
	function foo(p = x + 1) {
		console.log(p)
	}
	var x = 99;
	foo() // 100
	x = 100;
	foo() // 101

	var x8 = 1
	function fun8(yy = x8) {
		let x8 = 2
		console.log(yy) //1
		console.log(x8) //2
	}
	fun8()

	let foo8 = 'outer'
	function fun82 (func = (x) => foo8) {
		// 默认值单独作用域
		let foo8 = 'inner'
		console.log(func()) //outer
	}
	fun82()

	// 可以访问到外部变量
	function callback() {
		console.log(x9)
	}
	function autorun(cb){
	    let x9 = 1;
	    setTimeout(function log(){
	      console.log(x9); //1
	    }, 1000);
	    // cb()
	}
	autorun(callback);
	// 可以访问到外部函数参数
	(function autorun(p){
	    let x9 = 1;
	    setTimeout(function log(){
	      console.log(x9);//1
	      console.log(p);//10
	    }, 1000);
	})(10);
	(function autorun(){
	    let x9 = 1;
	    // 报错
	    setTimeout(callback, 1000);
	})();

	(function autorun(){
	    let x9 = 1;
	    function log(){
	      console.log(x9);
	    };
	    
	    function run(fn){
	      let x9 = 100;
	      fn();
	    }
	    
	    run(log);//1
	})();

</script>
</body>
</html>
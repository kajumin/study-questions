<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
<!-- 
	generator函数是异步任务的容器, 异步操作需要暂停的地方都用yield语句注明.

	(1)调用函数会返回一个内部指针, 调用指针的next可以移动内部指针, 指向第一个遇到的yield语句, next方法的作用是分阶段执行generator函数, 每次调用next方法都会返回一个对象, 表示当前阶段的信息(value和done属性), value属性是yield语句后面表达式的值, 表示当前阶段的值, done是一个布尔值, 表示generator函数是否执行完毕, 是否还有下一阶段
	(非第一次执行next时注意): 上一个yield语句是没有返回值的, yield的返回值是通过next传进来的

	generator函数可以暂停和恢复执行, 这是能封装异步任务的根本原因, 还有两个特性: 函数体内外的数据交换和错误处理机制
	(1)next可以传递数据
	(2)g.throw('出错了')  可以抛出错误
-->
 <script type="text/javascript">
 	function* gen (x) {
 		var y = yield x + 1
 		return y
 	}
 	var g = gen (2)
 	console.log(g.next()) 
 	console.log(g.next(2))
 	// {value:3, done: false}
 	// {value:2, done: true}

 	// 捕获函数体外抛出的错误
 	function* gen (x) {
 		try {
 			var y = yield x + 1

 		} catch (err) {
 			console.log(err)
 		}
 		return y
 	}
 	var g2 = gen(2)
 	console.log(g2.next())
 	g2.throw('出错了')
 	// {value:3, done: false}


	// yield语句是没有返回值的, yield的返回值是通过next传进来的
	// 第二个next没有传递参数, 所以y的值就是undefined, undefined/3结果为NaN
	// done属性表示是否执行完, 当最后一个yield执行之后, 再调用next()返回的对象done属性就为true 


 	// function* calc (x) {
 	// 	var y = 2 * (yield (x + 1))
 	// 	// console.log(y)
 	// 	var z = yield (y / 3)
 	// 	// console.log(z)
 	// 	return x + y + z  
 	// }
 	// var nt = calc(5)
 	// console.log(nt.next())
 	// console.log(nt.next())
 	// console.log(nt.next())
 	// console.log(nt.next())
 	// {value: 6, done:false}
 	// {value: NaN, done:false}
 	// {value: NaN, done:true}
 	// {value: undefined, done:true}
 	console.log(undefined + 5)

 	// 16杯毒酒, 多少只老鼠试出哪杯是毒酒?
	// 4 4 6 1 1
 	// 4只老鼠喝1杯(相同) 确定1杯
 	// 6只老鼠喝4杯中2杯(不同) 确定6杯
 	// 4只老鼠喝4杯中3杯(不同) 确定4杯
 	// 1只老鼠喝4杯中1杯(不同) 确定4杯
 	// 4只老鼠喝0杯(相同) 确定1杯

 </script>
</body>
</html>
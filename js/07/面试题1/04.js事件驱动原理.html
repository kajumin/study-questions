<!DOCTYPE html>
<html>
<head>
	<title></title>
	<style type="text/css">
		.box1 {
			width: 100px;
			height: 100px;
			background-color: red;
		}
	</style>
</head>
<body>
	<div class="box1"></div>
	<input type="text" name="" class="text" >
	<select class="select">
		<option value="1">1</option>
		<option value="2">2</option>
		<option value="3">3</option>
	</select>
	<button class="btn">测试异步任务的执行顺序</button>
	<!-- 
	1.js是单线程的, 所有js代码都在一个主线程上运行, 如果大量i/o请求, 都是同步执行的话会导致页面卡.
	  事件驱动是为了解决单通道阻塞问题, 通过事件队列的方式让主通道让路 
	 -->
	<!-- 事件:
	鼠标事件: click dbclick mouseover mouseout mousedown mousemove mouseup
	键盘事件: keydown keypress keyup
	其他事件: onload abort error 文本框select
	  -->
	<!-- 浏览器是多线程的
	1.GUI渲染线程   负责页面的渲染 与js引擎线程互斥
	2.js引擎线程    负责执行js代码
	3.事件触发线程  负责将准备好的事件交给任务队列, 等待js引擎线程执行。
	4.定时器触发线程  负责执行异步定时器一类的函数的线程, 计时完成后, 事件触发线程加入任务队列中
	4.异步请求http线程 负责执行异步请求一类的函数的线程, 当监听到状态码变更，如果有回调函数，事件触发线程会将回调函数加入到任务队列的队尾, 等待执行
	   -->
  	<!-- 
	宏任务(大任务)和微任务(小任务)
	微任务性能高于宏任务
	微任务: promise.then MutationObserver process.nextTick queueMicrotask 
	优先级: 微任务 > 宏任务  同级在前面定义的先执行
    -->
    <!-- 
    	js主线程(堆, 栈)  
	堆内存: 对象数组
	栈内存: 函数执行过程中的局部变量, 但函数执行的时候, 被推入栈顶 
	当遇到异步任务时, 提交给对应的异步线程处理(ajax, setTimeout dom事件) -> 当异步任务完成, 推入任务队列中

	当主线程执行完, 查询任务队列, 取出一个任务, 推入主线程处理, 重复该动作 => 该动作称为事件循环
     -->


<script type="text/javascript">
	var box1 = document.querySelector('.box1')
	var sel = document.querySelector('.select')
	var text = document.querySelector('.text')
	var btn = document.querySelector('.btn')
	box1.onmouseenter = function() {
		console.log('onmouseenter')
	}
	sel.onchange = function(e) {
		console.log('onchange')
		console.log(e.selected)
	}
	btn.onclick = function(e) {
		setTimeout(() => {
			console.log('setTimeout')
		}, 0)
		queueMicrotask(() => {
			console.log('queueMicrotask')
		})
		console.log('script end')
	}

	
</script>
</body>
</html>
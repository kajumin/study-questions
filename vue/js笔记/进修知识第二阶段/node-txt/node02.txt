文件系统
1.简单web开发   express+ejs + mongodb/mysql
2.聊天室  express + socket.io
3.爬虫  cheerio/request
4.博客系统   hexo
5.论坛  node club
6.控制台工具tty.js
7.在线游戏 Pomelo
==========测试单元
1.Mocha
2.断言库  should.js
3.路由测试  supertest
4.测试覆盖率   instanbul
5.Travis-cli   
============nginx  反向反代理服务器
const fs = require('fs');
最后一个参数为回调函数  回调函数的第一个参数为err   错误优先的原则

fs.unlink('hello',(err)=>{console.log()})  删除hello文件
unlinkSync
rename   第二个参数为改变后的名字
stat   获取文件信息

类和文件的基本信息
stats 获取文件相关的信息
stats.isFile()   是否是标准文件
stats.isDirectory()  是否是目录
stats.isBlockDevice()     是否是字符串设备
stats.isSymblicLink()   是否是符号连接   fs.lstat()返回的stats对象才有这个方法
stats.isFIFO()   是否是FIFO    unix中一种特殊类型的命令通道
stats.isSocket()   是否是unix套接字


fs.open(path,flags[,mode],callback);
flags  文件打开的方式
mode设置文件模式(权限)  一般可读写
r+    读写   
r      读取
rs     同步读取
rs+   同步读写
w      写入模式   不存在则创建
wx     跟w一样   但存在则报错
w+  读写方式打开文件,不存在则创建
wx+  跟wx类似  存在则读写失败
a       以追加模式打开   不存在则创建
ax     类似a    但存在路径则追加失败
callback  回调函数  两个参数


读取文件
fs.read(fd,buffer,offset,length,position,callback)
fd   通过fs.open返回的描述符
buffer  数据写入缓存
offset  缓冲区写入的写入偏移量
position   文件读取的起始位置  如为null 当前指针读起
callback(err,bytesRead(字节数),buffer(缓冲区对象))

readFile(filename[, option], callback)
option  (encoding  => null ,flag => r)


写入文件
fs.writeFile(filename, data[,options], callback);
data:  字符串或者buffer流对象
encoding: utf8
flag: w

fs.appendFile(filename, data[,options], callback);

============博客项目实战
express是一个简洁而灵活的node.jsweb应用框架,提供了一系列强大特性帮助你创建各种web应用
和丰富的http工具,使用express可以快速搭建一个完整功能的网站
======核心
1.可以设置中间件来响应http请求
2.定义了路由表用来执行不同的http请求动作
3.可以通过向模板传递参数来动态渲染html页面

npm install express-generator -g   npm install -g express
express -e blog(项目名称)

============================注意点
服务器重启后session不存在
==========================package.json
    "cookie-parser": "~1.4.4",  //没有使用
    "crypto": "^1.0.1",            //md5加密
    "debug": "~2.6.9",           
    "ejs": "~2.6.1",                 //模板引擎
    "express": "~4.16.1",        //快速初始项目
    "express-session": "^1.17.0",   //session处理
    "http-errors": "~1.6.3",
    "morgan": "~1.9.1",
    "mysql": "^2.18.1",            //mysql数据库
    "normalize.css": "^8.0.1",     //样式初始化
    "serve-favicon": "^2.5.0"
============================记录重要都方法
1.数据库
var mysql = require('mysql');
const database = mysql.createConnection({
    host: config.host,
    user: config.user,
    port: config.port,
    password: config.password,
    database: config.database
});
const conn = database.connect(); //连接数据库
conn.query(sql, function(err, rows, feilds) {   //查询数据
	if(err) {
	console.log(err)
	return;
 	}
	res.redirect('/');
})；
conn.escape(content); //处理提交的数据  

2.md5加密
var crypto = require('crypto');
var password = crypto.createHash('md5').update(password).digest('hex');  //以上三步加密password

3.session使用
app.use(session({
	secret: 'blog',
	cookie: { maxAge: 1000*60*24*30 },
	resave: false,
	saveUninitialized: true
}));  //路由配置
var session = require('express-session');
req.session.user = user;  // 设置和查询都使用req.sesssion

4.路由
====app.js
var express = require('express');
var router = express.Router();
var usersRouter = require('./routes/usersRouter');  //导入路由对象   在app.js
app.use('/users', usersRouter);   //使用路由对象   在app.js
====users路由
var express = require('express');
var router = express.Router();
router.get('/', function(req, res, next) {  }
module.exports = router;

5.日志
var logger = require('morgan');
// 日志分隔
var FileStreamRotator = require('file-stream-rotator');
// 日志中间件
app.use(logger('dev'));  //打印到控制台 
var logDirectory = path.join(__dirname, 'log');
fs.existsSync(logDirectory) || fs.mkdirSync(logDirectory);
var accessLog = fs.createWriteStream(logDirectory, {flags : 'a'}); 
var accessLogStream = FileStreamRotator.getStream({
 	date_format: 'YYYYMMDD',
 	filename: path.join(logDirectory, 'access-%DATE%.log'),
 	frequency: 'daily',
 	verbose: false
}) 
// short  combined类型选择
app.use(logger('short', {stream : accessLogStream}));      //打印到log日志 

6.body请求体数据处理   使用body-parser  和express(4.16.1)自带的都可以
//express自带的
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
//body-parser
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));

7.静态资源获取
app.use(express.static(path.join(__dirname, 'public')));

8.模板引擎
// 视图所在位置
app.set('views', path.join(__dirname, 'views'));
// 设置项目中使用的模板引擎
app.set('view engine', 'ejs');
res.render('login', { message: ''});  //加载login视图
app.locals.users   //设置每个视图都可以使用的数据  
==ejs用法
<%- include('./public/aside.ejs') %>//导入其他视图  <%- include('./public/aside.ejs')%>
<% if() {  }%>
<%= message %>
==art-template用法
{{each users $value $i}}
{{$value.name}}  //输出变量
{{include './list.art' list=value}}  模板嵌套模板

9.自己写中间件
app.use(fn({a: 2}));
function fn(obj) {
   return function(req, res,next) {
	if(obj.a == 1) {
		res.send(req.url);
		console.log(req.url);
	}else{
		res.send(req.method);
		console.log(req.method);
	}
	next();
     } 
}
=====其他一些方法
1.res.redirect('/');  //调转
2.res.status(200)send(req.name);	//最原始的输出办法
3.next();交给下一个中间件处理 
4.req.query  获取http://localhost:3000/index?name=bang  得到 {"name": "bang"}
5.body-parser转变后  req.body
6. http://localhost:3000/index/1/bang/20   
app.get('/index/:id/:name/:age',  (req, res) =>{}
req.params  {"id":"1","name":"bang","age":"20"}
7.Math.ceil(articleNum / limit);  //向下取值

=====express简单使用
1.响应请求 get  post 
2.中间件  next()
3.req.hostname   path query ip method  params  
4.res  res.send  res.jsonp  res.redirect   res.readfile  res.sendState
简单文件读取
readFile(path[,option],function(){})
writeFile(path,data,function(){})

流式文件读取
var rs = fs.createReadSteam(path[,option]);
var ws = fs.createWriteSteam(path[,option]);
rs.pipe(ws)  可读流直接到可写
rs.once('open',function(){})
rs.once('close',function(){})
rs.on('data',function(data){})
ws.end(data);


fs.existsSync(path); //不用了
fs.stat(path,function(err,result) { result.size result.isFile   result.isDirectory});     //状态
fs.access(path);
fs.unlink(path)  //删除文件
fs.readdir(path, err,file)
truncate(path,length)  length字节
mkdir(path [,mode], callback)
rmdir(path)
renamedir(oldpath,newpath)  剪切作用
watchFile(pathname{ interval: 1000}function(curr,prev){
stats 对象})  //监视文件修改

buffer  缓存区    相当于数组   存二进制   显示十六进制
bf = buffer.form(str);
bf.length

const bf = Buffer.alloc(10);
const bf = Buffer.allocUnsafe(10);





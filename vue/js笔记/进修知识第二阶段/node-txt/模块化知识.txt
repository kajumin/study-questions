=================模块化
seajs / require : 是一种在线"编译" 模块的方案，相当于在页面上加载一个 CMD/AMD 解释器。
browserify / webpack : 是一个预编译模块的方案，相比于上面 ，这个方案更加智能。
不管是 AMD / CMD / ES6 风格的模块化，它都能认识，并且编译成浏览器认识的JS。

1.文件与文件之间的依赖不明确
2.命名冲突问题
发展史:
一个函数一个模块(全局污染,没有直接关系)   =>  对象方法(容易被改变状态) =>  立即执行函数(返回对象方法)
=================common.js   node环境下  服务端模块化规范

=============暴露模块  数据是函数或者对象
    module.exports = value;   // 优先级更高    module.exports是exports的引用
    exports.xxx = value;      module.exports.xxx = value缩写
    exports = {}   不是缩写   module.exports = {} 

=============引用模块
    var module = require(模块名或模块路径);   相对路径需要加上(./)
    var uniq = require('uniq');
=============模块标识符
    核心模块(Node.js自带的模块)
    路径模块(相对或绝对定位开始的模块)   
    自定义模块(node_modules里的模块)  
    以:  require(./find)  为例
第一步之前,当前目录下 文件名.js被执行
第一步, 找出目录下的package.json, 用JSON.parse()解析出main字段
第二步, 如果main字段指定的文件还是省略了扩展, 那么会依次补充.js, .node, .json尝试.
第三步, 如果main字段制定的文件不存在, 或者根本就不存在package.json, 那么会默认加载这个目录下的
index.js, index.node, index.json文件.  不会去找文件名.js

(1)当前node_modules下找  如果main字段制定的文件不存在, 或者根本就不存在package.json, 那么会默认加载这个目录下的index.js, index.node, index.json文件.
(2)没有就向上级找node_modules中找

==========CommonJS规范的特点
(1)所有代码都运行在模块作用域，不会污染全局作用域；
(2)模块是同步加载的，即只有加载完成，才能执行后面的操作；
(3)模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存；  (修改了再引用还是修改后的值)
(4)CommonJS输出是值的拷贝, 模块内部数据改变, 基本数据类型不会被影响 引用类型会被影响

=============common.js在浏览器环境下
1.编写package文件
2.安装全局的browserify   还要安装局部
npm install browserify   -g
npm install browserify   --save-dev
browserify  js/src/app.js -o  js/dist/bundle.js
=======================AMD  浏览器可以直接使用  异步加载模块
用require.config()指定引用路径等，用define()定义模块，用require()加载模块。
首先我们需要引入require.js文件和一个入口文件main.js。main.js中配置require.config()并规定项目中用到的基础模块。
引用模块的时候，我们将模块名放在[]中作为reqiure()的第一参数；如果我们定义的模块本身也依赖其他模块,那就需要将它们放在[]中作为define()的第一参数。

require.js 
1.引入require.js  设置属性 data-main = "./js/app"
2.配置app.js   require.config({
   //基本路径
    baseUrl: "js/",
    //模块标识名与模块路径映射
    paths: {
      //第三方库
      'jquery' : 'libs/jquery-1.10.1',
      'angular' : 'libs/angular',
      'angular-messages' : 'libs/angular-messages',
      //自定义模块
      "alerter": "modules/alerter",
      "dataService": "modules/dataService"
    },
     /*
     // 配置不兼容AMD的模块
     exports : 指定导出的模块名
     deps  : 指定所有依赖的模块的数组
     */
    shim: {
      'angular' : {
        exports : 'angular'
      },
      'angular-messages' : {
        exports : 'angular-messages',
        deps : ['angular']
      }
    }
})

================定义模块
define(id?, dependencies?, factory)
id  个字符串，表示模块的名称，可选的
dependencies: 数组，要依赖d 模块，数组中的每一项表示的是要依赖模块的相对路径，可选的
factory: 工厂方法，一个函数，这里面就是具体的模块内容了

================引用模块
require(['math'],function(math) {} )

//引入使用模块
require( ['alerter', 'angular', 'angular-messages'], function(alerter, angular) {
    alerter.showMsg()
    angular.module('myApp', ['ngMessages'])
    angular.bootstrap(document,["myApp"])
  })
})()

3.其他模块文件
define(['dataService', 'jquery'], function (dataService, $) {
  let name = 'Tom2'

  function showMsg() {
    $('body').css('background', 'gray')
    alert(dataService.getMsg() + ', ' + name)
  }

  return { showMsg }
})

==========区别于CMD  异步加载模块。
(1)AMD   中会把当前模块的依赖模块放到dependencies中加载，并在factory回调中拿到加载成功的依赖
    CMD  一般不在dependencies中加载，而是写在factory中，使用require加载某个依赖模块
(==1) AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块
     2、CMD推崇就近依赖，只有在用到某个模块的时候再去require
=========================CMD============
使用seajs:
  1. 引入sea.js库
  2. 如何定义导出模块 :
    define()   define(function (require, exports, module) {  })    //三个参数是固定的
    exports    两种导出的方式
    module.exports
  3. 如何依赖模块:
    require()     var module2 = require('./module2'); 引入module2
  4. 如何使用模块:
    seajs.use()   //seajs.use('./js/modules/main')
-->
<script type="text/javascript" src="js/libs/sea.js"></script>
<script type="text/javascript">
  seajs.use('./js/modules/main')
</script>
=========================ES6
npm  install  browserify  --save-dev
1.准备一个package文件    
{
  "name" : "es6-babel-browserify",
  "version" : "1.0.0"
}
2.
npm i babel -cli  -g   全局安装
npm install babel-preset-es2015 --save-dev  开发环境的babel插件  翻译2015
3.定义预设文件  .babelrc   run  control 运行控制文件
{
  "presets": ["es2015"]
}
===================暴露模块  
modul.exports.name = 'bang';   两者指向不同对象时  以modul.exports为准
export { }
export var num = 2;   import {num} from './module1'   必须保持名字一样
export function foo() { }
export {fun1, fun2}  统一暴露
export default { }   默认暴露  导入的时候可以是任意名字
==================导入模块  采用了解构赋值的语法
import {foo, bar} from './module1'     
import {DATA_ARR} from './module1'
import {fun1, fun2} from './module2'
import { a as myA } from './module'   //换名
import * as module from './module'  //整体导入
import  person from './module3'       //默认导出


可以使用export {a} from  './a'  ==="中转"的效果
最终: 需要编译一下(两步)
babel  js/src -d  js/lib                                      es6 => es5   babel  js/src --out-dir  js/lib 同意思
babel  js/src/main.js -d  js/lib  编译一个文件  
browserify  js/lib/app.js -o  js/lib/bundle.js       common.js语法到浏览器

// 某个模块的导出 moudule.js
export const a = 1;
// 模块导入
// 1. 这里的a得和被加载的模块输出的接口名对应
import { a } from './module'                  //a
// 2. 使用 as 换名
import { a as myA } from './module'      //myA
// 3. 若是只想要运行被加载的模块可以这样写，但是即使加载2次也只是运行一次
import './module'
// 4. 整体加载
import * as module from './module'      //module.a
// 5. default接口和具名接口
import module, { a } from './module'    //a

特点:
动态引用 
输入模块变量不能重新赋值
import命令具有提升效果   不能在块级作用域中使用
===================区别于common.js 与  es6
(1)CommonJS   模块是运行时加载，ES6 Modules是编译时输出接口
(3)CommonJS   输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变
(3)CommonJS   this指向当前模块，ES6 Modules中this指向undefined
(4)CommonJs   导入的模块路径可以是一个表达式，因为它使用的是require()方法；而ES6 Modules只能是字符串
   
    CommonJS  加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
es6模块化的思想是尽量静态化, 使得编译时就能确定模块的依赖关系, 

模块作用域不会污染全局
同步加载
执行后会缓存
值的拷贝

6.引入第三方模块
npm install  jquery@1 --save   安装jquery  1.几最新版本   --save发布时也需要用到
import $ from 'jquery'    第三方模块采用的是默认暴露的方式

===babel   complier编译器   新包
npm i -g @babel/cli
npm i -g @babel/core
npm i -g @babel/preset-env

npm i -D  @babel/preset-env  @babel/core  以及其他插件

===webpack指导babel工作
npm i -D  babel-loader(加载器)  babel-core  babel-preset-env  webpack
loader加载器执行babel操作
mode: "development"
默认入口  src/index.js     默认出口  dist/main.js

========新版
npm i -D  babel-loader @babel/core  @babel/preset-env

node.js中使用label体验es模块化
npm i -D  @babel/cli  @babel/core  @babel/preset-env  @babel/node 
npm i @babel/polyfill
(1)默认导入导出(一次)  export default                       import m1 from './m1.js'
(2)按需导入导出(多次)  export let s1 = 'asss'              import { s1}  from './m1.js' 
(3)导入默认和按需   import m1, { s1 } from './m1.js'

模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。目前流行的js模块化规范有CommonJS、AMD、CMD以及ES6的模块系统。

循环加载
common.js  一个模块中加载另一个模块, 先去执行完另一个模块,该模块停止执行直到另一个模块执行完,
另一个模块循环加载第一个模块时,只能获取第一个模块已经执行完的值,console不会打印

es6 一个模块加载另一个模块会立即执行, 另一个模块加载第一个模块时不会重复执行, 继续执行该模块,
加载第一个模块的值可能取不到

===es6
es6模块化的思想是尽量静态化, 使得编译时就能确定模块的依赖关系, 以及输入和输出的变量, Commonjs和amd模块都是只能在运行时确定这些东西, 比如commonjs模块就是对象, 输入时必须查找对象属性.
let { stat, exists, readFile }  = require('fs')
等同于
let _fs = require('fs')
let stat = _fs.stat
let exists = _.exists
let readFile = _fs.readFile  整体加载整个对象,再从对象中获取值, 这种加载称为运行时加载, 因为只有运行时才能得到这个对象, 导致完全没办法在编译时进行静态分析
es6模块不是对象
import { stat, exists, readFile } from 'fs'
从fs中加载三个方法, 不加载其他方法, 这种称为编译时加载或者静态加载, es6可以在编译时就完成模块加载, 效率比Commonjs模块化的加载方式高,当然这也导致es6模块本身无法被引用, 因为它不是对象

webp  图片技术

ctrl+enter  下一行
ctrl + k +k 删除行
xml  悠久的数据格式    json遍历用for in 结合 for
1、必须有一个根元素，xml 也是由标签组成。开始标签，结束标签
2、不可有空格、不可以数字或.开头、大小写敏感
3、可以嵌套，不可交叉嵌套
4、属性双引号（浏览器自动修正成双引号了）
5、特殊符号要使用实体
6、注释和HTML一样
请求xml
1.服务端  header('Content-Type: text/xml');  header('Content-Type: application/xml');
2.客户端  this.responseXML.documentElement.children[0].innerHTML
              this.responseXML.documentElement.getElementsByTagName('name')[0]
==========================================================
AJAX技术  异步(XHR是ajax请求)    网络编程   浏览器提供的一套API  拿数据
使用XMLHttpRequest来和服务器进行异步通信, XMLHttpRequest是ajax的核心机制, 向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
1. var xhr = new XMLHttpRequest()
创建一个 XMLHttpRequest 类型的对象 ―― 相当于打开了一个浏览器
2. xhr.open('GET', './time.php') //可以是相对路径和绝对路径   可以加?username=bang  //第三个参数true为异步
打开与一个网址之间的连接 ―― 相当于在地址栏输入访问地址
3. xhr.send(null)  
    xhr.send
通过连接发送一次请求 ―― 相当于回车或者点击访问发送请求
4. xhr.onreadystatechange = function () {
   // 通过 xhr 的 readyState 判断此次请求的响应是否接收完成
    
    if (this.readyState === 4) {
    // 通过 xhr 的 responseText 获取到响应的响应体
        console.log(this.responseText)
        console.log(this.responseXML)   响应xml格式
    }
}
指定 xhr 状态变化事件处理函数 ―― 相当于处理网页呈现后的操作
5.readyState
   0: 初始化,请求代码对象  来没open调用
   1: 方法已经调用,建立一个与服务端特定端口的连接  没有调用send
   2: 已经接受到登录响应报文的响应头   调用了send
   3: 正在下载响应报文的响应体,有可能响应体为空,也可能不完整  处理响应体不保险
   4: 整个响应报文已经给完整下载下来了
6. xhr.onload = function(){ }                HTML5提供的  兼容问题
7. xhr.setRequestHeader('foo','bar')   设置请求头
    xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded')    post请求需要用
    xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');  默认
8.xhr.send('key=value&key2=value2') 设置请求体   需要跟setRequestHeader('Content-Type') 保持一致   post请求
9.GET POST异步请求及案例
10.console.time('name')计时方法 console.timeEnd('name') 两个名一样
11.async  和 sync  同步和异步
    xhr.open('GET', 'time.php', false)   false同步(阻塞)   默认true异步
12. xhr.responseType="json"  需要先设置  text   document   blob    response接收json
     this.responseText       返回text格式
     this.response              可接收json格式
     this.responseXML   返回的xml格式
     this.responseXML.documentElement.children[0].innerHTML)   获取xml格式某个文本
     this.responseXML.documentElement.getElementsByTagName('name')[0
14. 浏览器的console.log   展开后会是改变后的数据
15.JOSN.parse(this.response)转化为js对象  JSON.stringify(obj)转化为json对象
16.getResponseHeader(name)   响应头
    getAllResponseHeader()   获取全部请求头
    responseText           响应体       区别responseText 以字符串形式的响应体
    response                 响应体       区别response的结果会根据this.responseType的变化而变化
    responseXML
    responseType    'json'       兼容性
    timeout  默认为0   不限制 
    ontimeout
    abort   中断请求
17.携带cookie  xhr.withCredentials = true;
18.content-type:'application/json'   //在jquery中 默认application/x-www-form-urlencoded;
     文件上传时设置为content-type: false,  
19.processData : false,   //formData请求数据时就需要使用   不转换数据
20.traditional: false;       //默认fasle 对于处理数组数据时 true:  list=a&list=b  false:  list[]=a&list[]=b
=============
进程: 进行中的程序
线程: 拿着剧本(代码) 去演戏的演员   专业上是CPU最小执行单元
单核cup的多线程都是假的  切换出来的
======================================================================
模板引擎:art-template  doT  (ejs  Jade/pug  Handlbars)  Mustache   nunjucks
1.为什么不使用js变量中写模板   写到js中不方便  不能换行  没有着色 性能不佳
2.为什么使用script   script不会显示在页面中
3.<script type="text/x-art-template" id=tmp1></script>  准备一个模板引擎
{{each comments}} 中间是下面这行  {{/each}}
{{$value.name/author}}    获取值    {{$index}}  获取索引
4.var context = { comments: res.data }  模板所需要的数据res.data
5.var html = template('tmpl', context)   模板引擎API渲染数据为HTML
======================================================================
ajax封装: function ajax(method, url, params, done) { }
options.success && options.success(responseData);   一个处理有没有写回调函数的方法
我委托你帮我去拿一个数据  拿到过后去做什么事情(回调)
回调地狱: 死循环
$.ajax('time.php',{
    type:'POST',
    success:function(res){
         //拿到的是响应体
          console.log(res)
    }

})
$.ajax('time.php',{
    url:'time.php'
    type:'GET',
    data:{id:1,name:'bang'}
    success:function(res){
         //拿到的是响应体
          console.log(res)
    }

})
回调函数:
beforeSend:function(xhr,settings){ }
error:function(xhr){}
complete:function(xhr)  成功失败都会执行
快捷方法:
   $.get('http://localhost/ajax/json.php', { id: 1 }, function (res) {
      console.log(res)
    })

    $.post('http://localhost/ajax/json.php', { id: 1 }, function (res) {
      console.log(res)
    })

    $.getJSON('http://localhost/ajax/json.php', { id: 1 }, function (res) {
       console.log(res)
    })  
    //getJSON 用url传参数
$.get( url [, data ] [, success(data, textStatus, jqXHR) ] [, dataType ] )
$.post( url [, data ] [, success(data, textStatus, jqXHR) ] [, dataType ] )
$.getScript( url [, success(script, textStatus, jqXHR) ] )
$.getJSON( url [, data ] [, success(data, textStatus, jqXHR) ] )

2. 局部加载
$('#main').load(url + ' #main > *')   参数二data{ id:1 }   参数三callback(responseText, textStatus, XMLHttpRequest)
全局事件
$(document).ajaxStart(function(){    NProgress.start() })
$(document).ajaxStop(function(){    NProgress.done() })   用了Progress插件
loadstart  progress  load  loadend   e.loaded已加载
3. 同源策略: 同源之间才能进行ajax请求   域名  协议  端口完全相同     不同源默认不能访问
4. 不同源(域名协议端口)   跨域  访问不同域名的页面   跨域是浏览器限制的
方案一: header('Access-Control-Allow-Origin:*');    cors跨域资源共享 允许所有源跨源访问  不同源的解决方案在目标文件上加
方案二: jsonp   借助于script标签的可以发送不同源请求  客户端定义回调函数  服务端返回回调函数的调用 服务端的数据包含在参数中
            1.dataType: 'jsonp',    jquery中加上这个    与jquery中ajax请求差别
            2.jsonp: 'cb'               //向服务器传递函数名字的参数 =>callback
            3.jsonpCallback : 'fn'  //不用success  用fn
发请求: img  link  script  iframe   选择script的理由
(1)link 真正的定义：链入一个文档，通过 rel 属性申明链入的文档与当前文档之间的关系
请求不同源的地址
(2) var img=new Image()   img.src='http://locally.uieee.com/categories'         document.body.appendChild(img)
(3) var link = document.createElement('link')
    link.rel = 'stylesheet'
    link.href = 'https://cdn.bootcss.com/normalize/8.0.1/normalize.min.css'
    document.body.appendChild(link)
(4)  var script = document.createElement('script')    jsonp ( json padding )
      script.src = 'http://localhost/jsreturn.php'     jsreturn.php=>echo "foo({'time':12345678974})";   回调函数的意味
      document.body.appendChild(script) 
--返回的数据以js解析,所以需要写成回调函数
--script只支持get请求
--服务器与服务器之间没有跨域

前后端分离: 
1.接口安全问题:session认证和token认证
session需要登录后才能使用接口    不支持session cookie  小程序  android  ios
token 令牌  区块链(代币,通证)
301 302 303  重定向到服务器
304 重定向到缓存
500  服务器错误
==========================jquery.ajax
可以获取html文件
.ajaxSend( handler(event, jqXHR, ajaxOptions) )           开始之前
.ajaxComplete( handler(event, XMLHttpRequest, ajaxOptions) )  完成之后
.ajaxError( handler(event, jqXHR, ajaxSettings, thrownError) )
.ajaxStart( handler() )   开始
.ajaxStop( handler() )   结束
.ajaxSuccess( handler(event, XMLHttpRequest, ajaxOptions) )
$.ajaxSetup( options )  为之后的ajax设置一些属性

============================
formData
1.formData = new  FormData()
2.formData.append('username', 'Chris');   vs   form.set()
FormData.set 和 append() 的区别在于，如果指定的键已经存在， FormData.set 会使用新值覆盖已有的值，而 append() 会把新值添加到已有值集合的后面。
第三个参数:
传给服务器的文件名称 (一个 USVString), 当一个 Blob 或 File 被作为第二个参数的时候， Blob 对象的默认文件名是 "blob"。 File 对象的默认文件名是该文件的名称。
formData.append('userpic[]', myFileInput1.files[0], 'chris1.jpg');  多文件上传
4.delete(key)
5.entires()   返回一个迭代器   keys()  返回迭代器
6.get(key)   返回指定的第一个值   getAll()
7.has(key)  返回布尔值

birthday, 2020-02-04  date值   没选择为空
subject, 0   获取select值时  获取value中的值  没有再text值   没选择默认值
gender, 1   获取radio值时   获取value中的值   没选择不存在


======================restful  api分格
get       获取数据
post     添加数据
put      修改数据
delete  删除数据
/users    获取用户列表
/user/1  获取id为1的用户      服务器端/user/:id
/user?id=1  筛选出id=1



